# Atmosphere: an entity-component set

Atmosphere is our entity component set used to communicate between the
different subsystems. It assigns a numerical id to a resource which
can be used to get or set the value of different properties. For
example, `ways` will update the position property of a window. During
the next frame, vkcomp will read this updated position and use it to
draw that window in a new location.

Atmosphere is hyper-specific to category5. It is not general purpose,
and has weird design constraints unique to category5.

## Properties

Properties are defined by an enum with a set of variants containing
data. The variant data is the property datatype. Getters and Setters
for each property will be autogenerated.

As an example here is the set of per-client properties.
```
#[derive(Clone, Debug, AtmosECSGetSet)]
enum ClientProperty {
    // is this id in use?
    client_in_use(bool),
    // window ids belonging to this client
    windows_for_client(Vec<WindowId>),
}
```

A subsystem can then get the list of windows a client is associated
with using:
```
self.get_windows_for_client(client);
```

## Design

One of the reasons that the atmosphere exists is to isolate `ways`
from `vkcomp`. Because we want `vkcomp` to run in a different process
in some configurations, we don't want to give it access to
datastructures owned by `ways`.

The solution is to have a double-buffered database that tracks the
property values. There are two internal copies of the database, of
type `Hemisphere`, that each subsystem holds. Once at the beginning of
each frame, the two threads will *flip* hemispheres and replay any
new changes on top of the incoming hemisphere.

This also serves as the synchronization mechanism between the two
threads. Once `vkcomp` is done rendering, it will wait for the
hemispheres to flip. `ways` can control the rate that rendering occurs
by choosing when to flip hemispheres and give `vkcomp` the updated
property values.

The atmosphere uses getter/setters to interact with property values to
isolate the rest of the code from the internal data
representation. Atmosphere's internal mechanics for storing and
updating data can be changed without changing all of Category5.

## Property Map

A database needs to have a backing store, and ours is a
PropertyMap. Our property map converts a entity id (WindowId/ClientId)
and a property id into the value for that property. It needs to be
able to do a few things

* O(1) lookups
* Record changes to properties so they can be replayed later.
* Handle arbitrary property types

The constant-time lookup requirement is necessary to prevent excessive
cpu usage while the compositor is running. Properties will be set many
times a second, and it needs to be instant. This is done by using the
id values and indices into a lookup table. It essentially looks like
this:

```
Indexed by entity id
  v
  _
 |_| ---> v indexed by property id
 |_|     |_|  
 |_|	 |_|--> property value
 |_|	 |_|
 |_|	 |_|
 |_|
 |_|
 |_|
```

So a property lookup is two lookups: an index into the main table
using the entity id and a lookup into the property table using the
property id. Property indexes are automatically derived from the enums
specifying the property types.

The second two requirements are the motivation for using enums as the
property type: enums can be used to record a change to one
property. We can save a list of these enums to represent the list of
changes that has happened this frame and need to be replayed on the
hemisphere. The enums variants can hold any type of data that
implements Clone.

We then need a way to efficiently record the set of property changes that have
occurred during one frame. We do this by caching property changes into
a HashMap of the enums previously mentioned. This still allows for our
constant-time lookup, and makes sure we have one update for each
property modified. Effectively all changes during a frame happen in
this hashmap, which is then atomically applied to the hemisphere. We
"replay" these changes on our current hemisphere before sending it to
the other subsystem, and replay our changes over the incoming
hemisphere. Once changes are replayed on both, the hemispheres are
consistent.