/* automatically generated by rust-bindgen */

pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __size_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __pid_t = __int32_t;
pub type __uid_t = __uint32_t;
pub type __va_list = __builtin_va_list;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type uid_t = __uid_t;
pub type va_list = __va_list;
#[doc = " Protocol message signature"]
#[doc = ""]
#[doc = " A wl_message describes the signature of an actual protocol message, such as a"]
#[doc = " request or event, that adheres to the Wayland protocol wire format. The"]
#[doc = " protocol implementation uses a wl_message within its demarshal machinery for"]
#[doc = " decoding messages between a compositor and its clients. In a sense, a"]
#[doc = " wl_message is to a protocol message like a class is to an object."]
#[doc = ""]
#[doc = " The `name` of a wl_message is the name of the corresponding protocol message."]
#[doc = ""]
#[doc = " The `signature` is an ordered list of symbols representing the data types"]
#[doc = " of message arguments and, optionally, a protocol version and indicators for"]
#[doc = " nullability. A leading integer in the `signature` indicates the _since_"]
#[doc = " version of the protocol message. A `?` preceding a data type symbol indicates"]
#[doc = " that the following argument type is nullable. While it is a protocol violation"]
#[doc = " to send messages with non-nullable arguments set to `NULL`, event handlers in"]
#[doc = " clients might still get called with non-nullable object arguments set to"]
#[doc = " `NULL`. This can happen when the client destroyed the object being used as"]
#[doc = " argument on its side and an event referencing that object was sent before the"]
#[doc = " server knew about its destruction. As this race cannot be prevented, clients"]
#[doc = " should - as a general rule - program their event handlers such that they can"]
#[doc = " handle object arguments declared non-nullable being `NULL` gracefully."]
#[doc = ""]
#[doc = " When no arguments accompany a message, `signature` is an empty string."]
#[doc = ""]
#[doc = " Symbols:"]
#[doc = ""]
#[doc = " * `i`: int"]
#[doc = " * `u`: uint"]
#[doc = " * `f`: fixed"]
#[doc = " * `s`: string"]
#[doc = " * `o`: object"]
#[doc = " * `n`: new_id"]
#[doc = " * `a`: array"]
#[doc = " * `h`: fd"]
#[doc = " * `?`: following argument is nullable"]
#[doc = ""]
#[doc = " While demarshaling primitive arguments is straightforward, when demarshaling"]
#[doc = " messages containing `object` or `new_id` arguments, the protocol"]
#[doc = " implementation often must determine the type of the object. The `types` of a"]
#[doc = " wl_message is an array of wl_interface references that correspond to `o` and"]
#[doc = " `n` arguments in `signature`, with `NULL` placeholders for arguments with"]
#[doc = " non-object types."]
#[doc = ""]
#[doc = " Consider the protocol event wl_display `delete_id` that has a single `uint`"]
#[doc = " argument. The wl_message is:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " { \"delete_id\", \"u\", [NULL] }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " Here, the message `name` is `\"delete_id\"`, the `signature` is `\"u\"`, and the"]
#[doc = " argument `types` is `[NULL]`, indicating that the `uint` argument has no"]
#[doc = " corresponding wl_interface since it is a primitive argument."]
#[doc = ""]
#[doc = " In contrast, consider a `wl_foo` interface supporting protocol request `bar`"]
#[doc = " that has existed since version 2, and has two arguments: a `uint` and an"]
#[doc = " object of type `wl_baz_interface` that may be `NULL`. Such a `wl_message`"]
#[doc = " might be:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " { \"bar\", \"2u?o\", [NULL, &wl_baz_interface] }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " Here, the message `name` is `\"bar\"`, and the `signature` is `\"2u?o\"`. Notice"]
#[doc = " how the `2` indicates the protocol version, the `u` indicates the first"]
#[doc = " argument type is `uint`, and the `?o` indicates that the second argument"]
#[doc = " is an object that may be `NULL`. Lastly, the argument `types` array indicates"]
#[doc = " that no wl_interface corresponds to the first argument, while the type"]
#[doc = " `wl_baz_interface` corresponds to the second argument."]
#[doc = ""]
#[doc = " \\sa wl_argument"]
#[doc = " \\sa wl_interface"]
#[doc = " \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Wire-Format\">Wire Format</a>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_message {
    #[doc = " Message name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Message signature"]
    pub signature: *const ::std::os::raw::c_char,
    #[doc = " Object argument interfaces"]
    pub types: *mut *const wl_interface,
}
#[test]
fn bindgen_test_layout_wl_message() {
    assert_eq!(
        ::std::mem::size_of::<wl_message>(),
        24usize,
        concat!("Size of: ", stringify!(wl_message))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_message>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_message>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_message),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_message>())).signature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_message),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_message>())).types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_message),
            "::",
            stringify!(types)
        )
    );
}
#[doc = " Protocol object interface"]
#[doc = ""]
#[doc = " A wl_interface describes the API of a protocol object defined in the Wayland"]
#[doc = " protocol specification. The protocol implementation uses a wl_interface"]
#[doc = " within its marshalling machinery for encoding client requests."]
#[doc = ""]
#[doc = " The `name` of a wl_interface is the name of the corresponding protocol"]
#[doc = " interface, and `version` represents the version of the interface. The members"]
#[doc = " `method_count` and `event_count` represent the number of `methods` (requests)"]
#[doc = " and `events` in the respective wl_message members."]
#[doc = ""]
#[doc = " For example, consider a protocol interface `foo`, marked as version `1`, with"]
#[doc = " two requests and one event."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " <interface name=\"foo\" version=\"1\">"]
#[doc = "   <request name=\"a\"></request>"]
#[doc = "   <request name=\"b\"></request>"]
#[doc = "   <event name=\"c\"></event>"]
#[doc = " </interface>"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " Given two wl_message arrays `foo_requests` and `foo_events`, a wl_interface"]
#[doc = " for `foo` might be:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " struct wl_interface foo_interface = {"]
#[doc = "         \"foo\", 1,"]
#[doc = "         2, foo_requests,"]
#[doc = "         1, foo_events"]
#[doc = " };"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\note The server side of the protocol may define interface <em>implementation"]
#[doc = "       types</em> that incorporate the term `interface` in their name. Take"]
#[doc = "       care to not confuse these server-side `struct`s with a wl_interface"]
#[doc = "       variable whose name also ends in `interface`. For example, while the"]
#[doc = "       server may define a type `struct wl_foo_interface`, the client may"]
#[doc = "       define a `struct wl_interface wl_foo_interface`."]
#[doc = ""]
#[doc = " \\sa wl_message"]
#[doc = " \\sa wl_proxy"]
#[doc = " \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Interfaces\">Interfaces</a>"]
#[doc = " \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-Versioning\">Versioning</a>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_interface {
    #[doc = " Interface name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Interface version"]
    pub version: ::std::os::raw::c_int,
    #[doc = " Number of methods (requests)"]
    pub method_count: ::std::os::raw::c_int,
    #[doc = " Method (request) signatures"]
    pub methods: *const wl_message,
    #[doc = " Number of events"]
    pub event_count: ::std::os::raw::c_int,
    #[doc = " Event signatures"]
    pub events: *const wl_message,
}
#[test]
fn bindgen_test_layout_wl_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_interface>(),
        40usize,
        concat!("Size of: ", stringify!(wl_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).version as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).method_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(method_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).methods as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).event_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(event_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_interface>())).events as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_interface),
            "::",
            stringify!(events)
        )
    );
}
#[doc = " \\class wl_list"]
#[doc = ""]
#[doc = " \\brief Doubly-linked list"]
#[doc = ""]
#[doc = " On its own, an instance of `struct wl_list` represents the sentinel head of"]
#[doc = " a doubly-linked list, and must be initialized using wl_list_init()."]
#[doc = " When empty, the list head's `next` and `prev` members point to the list head"]
#[doc = " itself, otherwise `next` references the first element in the list, and `prev`"]
#[doc = " refers to the last element in the list."]
#[doc = ""]
#[doc = " Use the `struct wl_list` type to represent both the list head and the links"]
#[doc = " between elements within the list. Use wl_list_empty() to determine if the"]
#[doc = " list is empty in O(1)."]
#[doc = ""]
#[doc = " All elements in the list must be of the same type. The element type must have"]
#[doc = " a `struct wl_list` member, often named `link` by convention. Prior to"]
#[doc = " insertion, there is no need to initialize an element's `link` - invoking"]
#[doc = " wl_list_init() on an individual list element's `struct wl_list` member is"]
#[doc = " unnecessary if the very next operation is wl_list_insert(). However, a"]
#[doc = " common idiom is to initialize an element's `link` prior to removal - ensure"]
#[doc = " safety by invoking wl_list_init() before wl_list_remove()."]
#[doc = ""]
#[doc = " Consider a list reference `struct wl_list foo_list`, an element type as"]
#[doc = " `struct element`, and an element's link member as `struct wl_list link`."]
#[doc = ""]
#[doc = " The following code initializes a list and adds three elements to it."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " struct wl_list foo_list;"]
#[doc = ""]
#[doc = " struct element {"]
#[doc = "         int foo;"]
#[doc = "         struct wl_list link;"]
#[doc = " };"]
#[doc = " struct element e1, e2, e3;"]
#[doc = ""]
#[doc = " wl_list_init(&foo_list);"]
#[doc = " wl_list_insert(&foo_list, &e1.link);   // e1 is the first element"]
#[doc = " wl_list_insert(&foo_list, &e2.link);   // e2 is now the first element"]
#[doc = " wl_list_insert(&e2.link, &e3.link); // insert e3 after e2"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " The list now looks like <em>[e2, e3, e1]</em>."]
#[doc = ""]
#[doc = " The `wl_list` API provides some iterator macros. For example, to iterate"]
#[doc = " a list in ascending order:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " struct element *e;"]
#[doc = " wl_list_for_each(e, foo_list, link) {"]
#[doc = "         do_something_with_element(e);"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " See the documentation of each iterator for details."]
#[doc = " \\sa http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/list.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_list {
    #[doc = " Previous list element"]
    pub prev: *mut wl_list,
    #[doc = " Next list element"]
    pub next: *mut wl_list,
}
#[test]
fn bindgen_test_layout_wl_list() {
    assert_eq!(
        ::std::mem::size_of::<wl_list>(),
        16usize,
        concat!("Size of: ", stringify!(wl_list))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_list>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_list>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_list),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_list>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_list),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Initializes the list."]
    #[doc = ""]
    #[doc = " \\param list List to initialize"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_init(list: *mut wl_list);
}
extern "C" {
    #[doc = " Inserts an element into the list, after the element represented by \\p list."]
    #[doc = " When \\p list is a reference to the list itself (the head), set the containing"]
    #[doc = " struct of \\p elm as the first element in the list."]
    #[doc = ""]
    #[doc = " \\note If \\p elm is already part of a list, inserting it again will lead to"]
    #[doc = "       list corruption."]
    #[doc = ""]
    #[doc = " \\param list List element after which the new element is inserted"]
    #[doc = " \\param elm Link of the containing struct to insert into the list"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_insert(list: *mut wl_list, elm: *mut wl_list);
}
extern "C" {
    #[doc = " Removes an element from the list."]
    #[doc = ""]
    #[doc = " \\note This operation leaves \\p elm in an invalid state."]
    #[doc = ""]
    #[doc = " \\param elm Link of the containing struct to remove from the list"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_remove(elm: *mut wl_list);
}
extern "C" {
    #[doc = " Determines the length of the list."]
    #[doc = ""]
    #[doc = " \\note This is an O(n) operation."]
    #[doc = ""]
    #[doc = " \\param list List whose length is to be determined"]
    #[doc = ""]
    #[doc = " \\return Number of elements in the list"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_length(list: *const wl_list) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determines if the list is empty."]
    #[doc = ""]
    #[doc = " \\param list List whose emptiness is to be determined"]
    #[doc = ""]
    #[doc = " \\return 1 if empty, or 0 if not empty"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_empty(list: *const wl_list) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Inserts all of the elements of one list into another, after the element"]
    #[doc = " represented by \\p list."]
    #[doc = ""]
    #[doc = " \\note This leaves \\p other in an invalid state."]
    #[doc = ""]
    #[doc = " \\param list List element after which the other list elements will be inserted"]
    #[doc = " \\param other List of elements to insert"]
    #[doc = ""]
    #[doc = " \\memberof wl_list"]
    pub fn wl_list_insert_list(list: *mut wl_list, other: *mut wl_list);
}
#[doc = " \\class wl_array"]
#[doc = ""]
#[doc = " Dynamic array"]
#[doc = ""]
#[doc = " A wl_array is a dynamic array that can only grow until released. It is"]
#[doc = " intended for relatively small allocations whose size is variable or not known"]
#[doc = " in advance. While construction of a wl_array does not require all elements to"]
#[doc = " be of the same size, wl_array_for_each() does require all elements to have"]
#[doc = " the same type and size."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_array {
    #[doc = " Array size"]
    pub size: usize,
    #[doc = " Allocated space"]
    pub alloc: usize,
    #[doc = " Array data"]
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wl_array() {
    assert_eq!(
        ::std::mem::size_of::<wl_array>(),
        24usize,
        concat!("Size of: ", stringify!(wl_array))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_array>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_array))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_array>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_array),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_array>())).alloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_array),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_array>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_array),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Initializes the array."]
    #[doc = ""]
    #[doc = " \\param array Array to initialize"]
    #[doc = ""]
    #[doc = " \\memberof wl_array"]
    pub fn wl_array_init(array: *mut wl_array);
}
extern "C" {
    #[doc = " Releases the array data."]
    #[doc = ""]
    #[doc = " \\note Leaves the array in an invalid state."]
    #[doc = ""]
    #[doc = " \\param array Array whose data is to be released"]
    #[doc = ""]
    #[doc = " \\memberof wl_array"]
    pub fn wl_array_release(array: *mut wl_array);
}
extern "C" {
    #[doc = " Increases the size of the array by \\p size bytes."]
    #[doc = ""]
    #[doc = " \\param array Array whose size is to be increased"]
    #[doc = " \\param size Number of bytes to increase the size of the array by"]
    #[doc = ""]
    #[doc = " \\return A pointer to the beginning of the newly appended space, or NULL when"]
    #[doc = "         resizing fails."]
    #[doc = ""]
    #[doc = " \\memberof wl_array"]
    pub fn wl_array_add(array: *mut wl_array, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Copies the contents of \\p source to \\p array."]
    #[doc = ""]
    #[doc = " \\param array Destination array to copy to"]
    #[doc = " \\param source Source array to copy from"]
    #[doc = ""]
    #[doc = " \\return 0 on success, or -1 on failure"]
    #[doc = ""]
    #[doc = " \\memberof wl_array"]
    pub fn wl_array_copy(array: *mut wl_array, source: *mut wl_array) -> ::std::os::raw::c_int;
}
#[doc = " Fixed-point number"]
#[doc = ""]
#[doc = " A `wl_fixed_t` is a 24.8 signed fixed-point number with a sign bit, 23 bits"]
#[doc = " of integer precision and 8 bits of decimal precision. Consider `wl_fixed_t`"]
#[doc = " as an opaque struct with methods that facilitate conversion to and from"]
#[doc = " `double` and `int` types."]
pub type wl_fixed_t = i32;
#[doc = " Protocol message argument data types"]
#[doc = ""]
#[doc = " This union represents all of the argument types in the Wayland protocol wire"]
#[doc = " format. The protocol implementation uses wl_argument within its marshalling"]
#[doc = " machinery for dispatching messages between a client and a compositor."]
#[doc = ""]
#[doc = " \\sa wl_message"]
#[doc = " \\sa wl_interface"]
#[doc = " \\sa <a href=\"https://wayland.freedesktop.org/docs/html/ch04.html#sect-Protocol-wire-Format\">Wire Format</a>"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wl_argument {
    #[doc = "< `int`"]
    pub i: i32,
    #[doc = "< `uint`"]
    pub u: u32,
    #[doc = "< `fixed`"]
    pub f: wl_fixed_t,
    #[doc = "< `string`"]
    pub s: *const ::std::os::raw::c_char,
    #[doc = "< `object`"]
    pub o: *mut wl_object,
    #[doc = "< `new_id`"]
    pub n: u32,
    #[doc = "< `array`"]
    pub a: *mut wl_array,
    #[doc = "< `fd`"]
    pub h: i32,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_wl_argument() {
    assert_eq!(
        ::std::mem::size_of::<wl_argument>(),
        8usize,
        concat!("Size of: ", stringify!(wl_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_argument>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_argument))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).o as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(o)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_argument>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_argument),
            "::",
            stringify!(h)
        )
    );
}
#[doc = " Dispatcher function type alias"]
#[doc = ""]
#[doc = " A dispatcher is a function that handles the emitting of callbacks in client"]
#[doc = " code. For programs directly using the C library, this is done by using"]
#[doc = " libffi to call function pointers. When binding to languages other than C,"]
#[doc = " dispatchers provide a way to abstract the function calling process to be"]
#[doc = " friendlier to other function calling systems."]
#[doc = ""]
#[doc = " A dispatcher takes five arguments: The first is the dispatcher-specific"]
#[doc = " implementation associated with the target object. The second is the object"]
#[doc = " upon which the callback is being invoked (either wl_proxy or wl_resource)."]
#[doc = " The third and fourth arguments are the opcode and the wl_message"]
#[doc = " corresponding to the callback. The final argument is an array of arguments"]
#[doc = " received from the other process via the wire protocol."]
#[doc = ""]
#[doc = " \\param \"const void *\" Dispatcher-specific implementation data"]
#[doc = " \\param \"void *\" Callback invocation target (wl_proxy or `wl_resource`)"]
#[doc = " \\param uint32_t Callback opcode"]
#[doc = " \\param \"const struct wl_message *\" Callback message signature"]
#[doc = " \\param \"union wl_argument *\" Array of received arguments"]
#[doc = ""]
#[doc = " \\return 0 on success, or -1 on failure"]
pub type wl_dispatcher_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: u32,
        arg4: *const wl_message,
        arg5: *mut wl_argument,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Log function type alias"]
#[doc = ""]
#[doc = " The C implementation of the Wayland protocol abstracts the details of"]
#[doc = " logging. Users may customize the logging behavior, with a function conforming"]
#[doc = " to the `wl_log_func_t` type, via `wl_log_set_handler_client` and"]
#[doc = " `wl_log_set_handler_server`."]
#[doc = ""]
#[doc = " A `wl_log_func_t` must conform to the expectations of `vprintf`, and"]
#[doc = " expects two arguments: a string to write and a corresponding variable"]
#[doc = " argument list. While the string to write may contain format specifiers and"]
#[doc = " use values in the variable argument list, the behavior of any `wl_log_func_t`"]
#[doc = " depends on the implementation."]
#[doc = ""]
#[doc = " \\note Take care to not confuse this with `wl_protocol_logger_func_t`, which"]
#[doc = "       is a specific server-side logger for requests and events."]
#[doc = ""]
#[doc = " \\param \"const char *\" String to write to the log, containing optional format"]
#[doc = "                       specifiers"]
#[doc = " \\param \"va_list\" Variable argument list"]
#[doc = ""]
#[doc = " \\sa wl_log_set_handler_client"]
#[doc = " \\sa wl_log_set_handler_server"]
pub type wl_log_func_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char, arg2: *mut __va_list_tag),
>;
#[doc = " Stop the iteration"]
pub const wl_iterator_result_WL_ITERATOR_STOP: wl_iterator_result = 0;
#[doc = " Continue the iteration"]
pub const wl_iterator_result_WL_ITERATOR_CONTINUE: wl_iterator_result = 1;
#[doc = " Return value of an iterator function"]
#[doc = ""]
#[doc = " \\sa wl_client_for_each_resource_iterator_func_t"]
#[doc = " \\sa wl_client_for_each_resource"]
pub type wl_iterator_result = u32;
#[doc = " File descriptor dispatch function type"]
#[doc = ""]
#[doc = " Functions of this type are used as callbacks for file descriptor events."]
#[doc = ""]
#[doc = " \\param fd The file descriptor delivering the event."]
#[doc = " \\param mask Describes the kind of the event as a bitwise-or of:"]
#[doc = " \\c WL_EVENT_READABLE, \\c WL_EVENT_WRITABLE, \\c WL_EVENT_HANGUP,"]
#[doc = " \\c WL_EVENT_ERROR."]
#[doc = " \\param data The user data argument of the related wl_event_loop_add_fd()"]
#[doc = " call."]
#[doc = " \\return If the event source is registered for re-check with"]
#[doc = " wl_event_source_check(): 0 for all done, 1 for needing a re-check."]
#[doc = " If not registered, the return value is ignored and should be zero."]
#[doc = ""]
#[doc = " \\sa wl_event_loop_add_fd()"]
#[doc = " \\memberof wl_event_source"]
pub type wl_event_loop_fd_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        fd: ::std::os::raw::c_int,
        mask: u32,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Timer dispatch function type"]
#[doc = ""]
#[doc = " Functions of this type are used as callbacks for timer expiry."]
#[doc = ""]
#[doc = " \\param data The user data argument of the related wl_event_loop_add_timer()"]
#[doc = " call."]
#[doc = " \\return If the event source is registered for re-check with"]
#[doc = " wl_event_source_check(): 0 for all done, 1 for needing a re-check."]
#[doc = " If not registered, the return value is ignored and should be zero."]
#[doc = ""]
#[doc = " \\sa wl_event_loop_add_timer()"]
#[doc = " \\memberof wl_event_source"]
pub type wl_event_loop_timer_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Signal dispatch function type"]
#[doc = ""]
#[doc = " Functions of this type are used as callbacks for (POSIX) signals."]
#[doc = ""]
#[doc = " \\param signal_number"]
#[doc = " \\param data The user data argument of the related wl_event_loop_add_signal()"]
#[doc = " call."]
#[doc = " \\return If the event source is registered for re-check with"]
#[doc = " wl_event_source_check(): 0 for all done, 1 for needing a re-check."]
#[doc = " If not registered, the return value is ignored and should be zero."]
#[doc = ""]
#[doc = " \\sa wl_event_loop_add_signal()"]
#[doc = " \\memberof wl_event_source"]
pub type wl_event_loop_signal_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        signal_number: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Idle task function type"]
#[doc = ""]
#[doc = " Functions of this type are used as callbacks before blocking in"]
#[doc = " wl_event_loop_dispatch()."]
#[doc = ""]
#[doc = " \\param data The user data argument of the related wl_event_loop_add_idle()"]
#[doc = " call."]
#[doc = ""]
#[doc = " \\sa wl_event_loop_add_idle() wl_event_loop_dispatch()"]
#[doc = " \\memberof wl_event_source"]
pub type wl_event_loop_idle_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_event_loop {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " \\struct wl_event_source"]
    #[doc = ""]
    #[doc = " \\brief An abstract event source"]
    #[doc = ""]
    #[doc = " This is the generic type for fd, timer, signal, and idle sources."]
    #[doc = " Functions that operate on specific source types must not be used with"]
    #[doc = " a different type, even if the function signature allows it."]
    pub fn wl_event_loop_create() -> *mut wl_event_loop;
}
extern "C" {
    pub fn wl_event_loop_destroy(loop_: *mut wl_event_loop);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_event_source {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_event_loop_add_fd(
        loop_: *mut wl_event_loop,
        fd: ::std::os::raw::c_int,
        mask: u32,
        func: wl_event_loop_fd_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_event_source;
}
extern "C" {
    pub fn wl_event_source_fd_update(
        source: *mut wl_event_source,
        mask: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_event_loop_add_timer(
        loop_: *mut wl_event_loop,
        func: wl_event_loop_timer_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_event_source;
}
extern "C" {
    pub fn wl_event_loop_add_signal(
        loop_: *mut wl_event_loop,
        signal_number: ::std::os::raw::c_int,
        func: wl_event_loop_signal_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_event_source;
}
extern "C" {
    pub fn wl_event_source_timer_update(
        source: *mut wl_event_source,
        ms_delay: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_event_source_remove(source: *mut wl_event_source) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_event_source_check(source: *mut wl_event_source);
}
extern "C" {
    pub fn wl_event_loop_dispatch(
        loop_: *mut wl_event_loop,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_event_loop_dispatch_idle(loop_: *mut wl_event_loop);
}
extern "C" {
    pub fn wl_event_loop_add_idle(
        loop_: *mut wl_event_loop,
        func: wl_event_loop_idle_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_event_source;
}
extern "C" {
    pub fn wl_event_loop_get_fd(loop_: *mut wl_event_loop) -> ::std::os::raw::c_int;
}
pub type wl_notify_func_t = ::std::option::Option<
    unsafe extern "C" fn(listener: *mut wl_listener, data: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn wl_event_loop_add_destroy_listener(
        loop_: *mut wl_event_loop,
        listener: *mut wl_listener,
    );
}
extern "C" {
    pub fn wl_event_loop_get_destroy_listener(
        loop_: *mut wl_event_loop,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_display_create() -> *mut wl_display;
}
extern "C" {
    pub fn wl_display_destroy(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_get_event_loop(display: *mut wl_display) -> *mut wl_event_loop;
}
extern "C" {
    pub fn wl_display_add_socket(
        display: *mut wl_display,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_add_socket_auto(display: *mut wl_display) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wl_display_add_socket_fd(
        display: *mut wl_display,
        sock_fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_terminate(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_run(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_flush_clients(display: *mut wl_display);
}
extern "C" {
    pub fn wl_display_destroy_clients(display: *mut wl_display);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_client {
    _unused: [u8; 0],
}
pub type wl_global_bind_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        client: *mut wl_client,
        data: *mut ::std::os::raw::c_void,
        version: u32,
        id: u32,
    ),
>;
extern "C" {
    pub fn wl_display_get_serial(display: *mut wl_display) -> u32;
}
extern "C" {
    pub fn wl_display_next_serial(display: *mut wl_display) -> u32;
}
extern "C" {
    pub fn wl_display_add_destroy_listener(display: *mut wl_display, listener: *mut wl_listener);
}
extern "C" {
    pub fn wl_display_add_client_created_listener(
        display: *mut wl_display,
        listener: *mut wl_listener,
    );
}
extern "C" {
    pub fn wl_display_get_destroy_listener(
        display: *mut wl_display,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_global {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_global_create(
        display: *mut wl_display,
        interface: *const wl_interface,
        version: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
        bind: wl_global_bind_func_t,
    ) -> *mut wl_global;
}
extern "C" {
    pub fn wl_global_remove(global: *mut wl_global);
}
extern "C" {
    pub fn wl_global_destroy(global: *mut wl_global);
}
#[doc = " A filter function for wl_global objects"]
#[doc = ""]
#[doc = " \\param client The client object"]
#[doc = " \\param global The global object to show or hide"]
#[doc = " \\param data   The user data pointer"]
#[doc = ""]
#[doc = " A filter function enables the server to decide which globals to"]
#[doc = " advertise to each client."]
#[doc = ""]
#[doc = " When a wl_global filter is set, the given callback funtion will be"]
#[doc = " called during wl_global advertisment and binding."]
#[doc = ""]
#[doc = " This function should return true if the global object should be made"]
#[doc = " visible to the client or false otherwise."]
pub type wl_display_global_filter_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        client: *const wl_client,
        global: *const wl_global,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn wl_display_set_global_filter(
        display: *mut wl_display,
        filter: wl_display_global_filter_func_t,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn wl_global_get_interface(global: *const wl_global) -> *const wl_interface;
}
extern "C" {
    pub fn wl_global_get_user_data(global: *const wl_global) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_global_set_user_data(global: *mut wl_global, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wl_client_create(display: *mut wl_display, fd: ::std::os::raw::c_int) -> *mut wl_client;
}
extern "C" {
    pub fn wl_display_get_client_list(display: *mut wl_display) -> *mut wl_list;
}
extern "C" {
    pub fn wl_client_get_link(client: *mut wl_client) -> *mut wl_list;
}
extern "C" {
    pub fn wl_client_from_link(link: *mut wl_list) -> *mut wl_client;
}
extern "C" {
    pub fn wl_client_destroy(client: *mut wl_client);
}
extern "C" {
    pub fn wl_client_flush(client: *mut wl_client);
}
extern "C" {
    pub fn wl_client_get_credentials(
        client: *mut wl_client,
        pid: *mut pid_t,
        uid: *mut uid_t,
        gid: *mut gid_t,
    );
}
extern "C" {
    pub fn wl_client_get_fd(client: *mut wl_client) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_client_add_destroy_listener(client: *mut wl_client, listener: *mut wl_listener);
}
extern "C" {
    pub fn wl_client_get_destroy_listener(
        client: *mut wl_client,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
extern "C" {
    pub fn wl_client_get_object(client: *mut wl_client, id: u32) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_client_post_no_memory(client: *mut wl_client);
}
extern "C" {
    pub fn wl_client_post_implementation_error(
        client: *mut wl_client,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn wl_client_add_resource_created_listener(
        client: *mut wl_client,
        listener: *mut wl_listener,
    );
}
pub type wl_client_for_each_resource_iterator_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        resource: *mut wl_resource,
        user_data: *mut ::std::os::raw::c_void,
    ) -> wl_iterator_result,
>;
extern "C" {
    pub fn wl_client_for_each_resource(
        client: *mut wl_client,
        iterator: wl_client_for_each_resource_iterator_func_t,
        user_data: *mut ::std::os::raw::c_void,
    );
}
#[doc = " \\class wl_listener"]
#[doc = ""]
#[doc = " \\brief A single listener for Wayland signals"]
#[doc = ""]
#[doc = " wl_listener provides the means to listen for wl_signal notifications. Many"]
#[doc = " Wayland objects use wl_listener for notification of significant events like"]
#[doc = " object destruction."]
#[doc = ""]
#[doc = " Clients should create wl_listener objects manually and can register them as"]
#[doc = " listeners to signals using #wl_signal_add, assuming the signal is"]
#[doc = " directly accessible. For opaque structs like wl_event_loop, adding a"]
#[doc = " listener should be done through provided accessor methods. A listener can"]
#[doc = " only listen to one signal at a time."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " struct wl_listener your_listener;"]
#[doc = ""]
#[doc = " your_listener.notify = your_callback_method;"]
#[doc = ""]
#[doc = " // Direct access"]
#[doc = " wl_signal_add(&some_object->destroy_signal, &your_listener);"]
#[doc = ""]
#[doc = " // Accessor access"]
#[doc = " wl_event_loop *loop = ...;"]
#[doc = " wl_event_loop_add_destroy_listener(loop, &your_listener);"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " If the listener is part of a larger struct, #wl_container_of can be used"]
#[doc = " to retrieve a pointer to it:"]
#[doc = ""]
#[doc = " \\code"]
#[doc = " void your_listener(struct wl_listener *listener, void *data)"]
#[doc = " {"]
#[doc = " \tstruct your_data *data;"]
#[doc = ""]
#[doc = " \tyour_data = wl_container_of(listener, data, your_member_name);"]
#[doc = " }"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " If you need to remove a listener from a signal, use wl_list_remove()."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " wl_list_remove(&your_listener.link);"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\sa wl_signal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_listener {
    pub link: wl_list,
    pub notify: wl_notify_func_t,
}
#[test]
fn bindgen_test_layout_wl_listener() {
    assert_eq!(
        ::std::mem::size_of::<wl_listener>(),
        24usize,
        concat!("Size of: ", stringify!(wl_listener))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_listener>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_listener))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_listener>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_listener),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_listener>())).notify as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_listener),
            "::",
            stringify!(notify)
        )
    );
}
#[doc = " \\class wl_signal"]
#[doc = ""]
#[doc = " \\brief A source of a type of observable event"]
#[doc = ""]
#[doc = " Signals are recognized points where significant events can be observed."]
#[doc = " Compositors as well as the server can provide signals. Observers are"]
#[doc = " wl_listener's that are added through #wl_signal_add. Signals are emitted"]
#[doc = " using #wl_signal_emit, which will invoke all listeners until that"]
#[doc = " listener is removed by wl_list_remove() (or whenever the signal is"]
#[doc = " destroyed)."]
#[doc = ""]
#[doc = " \\sa wl_listener for more information on using wl_signal"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_signal {
    pub listener_list: wl_list,
}
#[test]
fn bindgen_test_layout_wl_signal() {
    assert_eq!(
        ::std::mem::size_of::<wl_signal>(),
        16usize,
        concat!("Size of: ", stringify!(wl_signal))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_signal>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_signal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_signal>())).listener_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_signal),
            "::",
            stringify!(listener_list)
        )
    );
}
pub type wl_resource_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(resource: *mut wl_resource)>;
extern "C" {
    pub fn wl_resource_post_event(resource: *mut wl_resource, opcode: u32, ...);
}
extern "C" {
    pub fn wl_resource_post_event_array(
        resource: *mut wl_resource,
        opcode: u32,
        args: *mut wl_argument,
    );
}
extern "C" {
    pub fn wl_resource_queue_event(resource: *mut wl_resource, opcode: u32, ...);
}
extern "C" {
    pub fn wl_resource_queue_event_array(
        resource: *mut wl_resource,
        opcode: u32,
        args: *mut wl_argument,
    );
}
extern "C" {
    pub fn wl_resource_post_error(
        resource: *mut wl_resource,
        code: u32,
        msg: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn wl_resource_post_no_memory(resource: *mut wl_resource);
}
extern "C" {
    pub fn wl_client_get_display(client: *mut wl_client) -> *mut wl_display;
}
extern "C" {
    pub fn wl_resource_create(
        client: *mut wl_client,
        interface: *const wl_interface,
        version: ::std::os::raw::c_int,
        id: u32,
    ) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_resource_set_implementation(
        resource: *mut wl_resource,
        implementation: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        destroy: wl_resource_destroy_func_t,
    );
}
extern "C" {
    pub fn wl_resource_set_dispatcher(
        resource: *mut wl_resource,
        dispatcher: wl_dispatcher_func_t,
        implementation: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        destroy: wl_resource_destroy_func_t,
    );
}
extern "C" {
    pub fn wl_resource_destroy(resource: *mut wl_resource);
}
extern "C" {
    pub fn wl_resource_get_id(resource: *mut wl_resource) -> u32;
}
extern "C" {
    pub fn wl_resource_get_link(resource: *mut wl_resource) -> *mut wl_list;
}
extern "C" {
    pub fn wl_resource_from_link(resource: *mut wl_list) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_resource_find_for_client(
        list: *mut wl_list,
        client: *mut wl_client,
    ) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_resource_get_client(resource: *mut wl_resource) -> *mut wl_client;
}
extern "C" {
    pub fn wl_resource_set_user_data(resource: *mut wl_resource, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wl_resource_get_user_data(resource: *mut wl_resource) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_resource_get_version(resource: *mut wl_resource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_resource_set_destructor(
        resource: *mut wl_resource,
        destroy: wl_resource_destroy_func_t,
    );
}
extern "C" {
    pub fn wl_resource_instance_of(
        resource: *mut wl_resource,
        interface: *const wl_interface,
        implementation: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_resource_get_class(resource: *mut wl_resource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn wl_resource_add_destroy_listener(resource: *mut wl_resource, listener: *mut wl_listener);
}
extern "C" {
    pub fn wl_resource_get_destroy_listener(
        resource: *mut wl_resource,
        notify: wl_notify_func_t,
    ) -> *mut wl_listener;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_buffer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_shm_buffer_get(resource: *mut wl_resource) -> *mut wl_shm_buffer;
}
extern "C" {
    pub fn wl_shm_buffer_begin_access(buffer: *mut wl_shm_buffer);
}
extern "C" {
    pub fn wl_shm_buffer_end_access(buffer: *mut wl_shm_buffer);
}
extern "C" {
    pub fn wl_shm_buffer_get_data(buffer: *mut wl_shm_buffer) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn wl_shm_buffer_get_stride(buffer: *mut wl_shm_buffer) -> i32;
}
extern "C" {
    pub fn wl_shm_buffer_get_format(buffer: *mut wl_shm_buffer) -> u32;
}
extern "C" {
    pub fn wl_shm_buffer_get_width(buffer: *mut wl_shm_buffer) -> i32;
}
extern "C" {
    pub fn wl_shm_buffer_get_height(buffer: *mut wl_shm_buffer) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_shm_buffer_ref_pool(buffer: *mut wl_shm_buffer) -> *mut wl_shm_pool;
}
extern "C" {
    pub fn wl_shm_pool_unref(pool: *mut wl_shm_pool);
}
extern "C" {
    pub fn wl_display_init_shm(display: *mut wl_display) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wl_display_add_shm_format(display: *mut wl_display, format: u32) -> *mut u32;
}
extern "C" {
    pub fn wl_shm_buffer_create(
        client: *mut wl_client,
        id: u32,
        width: i32,
        height: i32,
        stride: i32,
        format: u32,
    ) -> *mut wl_shm_buffer;
}
extern "C" {
    pub fn wl_log_set_handler_server(handler: wl_log_func_t);
}
pub const wl_protocol_logger_type_WL_PROTOCOL_LOGGER_REQUEST: wl_protocol_logger_type = 0;
pub const wl_protocol_logger_type_WL_PROTOCOL_LOGGER_EVENT: wl_protocol_logger_type = 1;
pub type wl_protocol_logger_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_protocol_logger_message {
    pub resource: *mut wl_resource,
    pub message_opcode: ::std::os::raw::c_int,
    pub message: *const wl_message,
    pub arguments_count: ::std::os::raw::c_int,
    pub arguments: *const wl_argument,
}
#[test]
fn bindgen_test_layout_wl_protocol_logger_message() {
    assert_eq!(
        ::std::mem::size_of::<wl_protocol_logger_message>(),
        40usize,
        concat!("Size of: ", stringify!(wl_protocol_logger_message))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_protocol_logger_message>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_protocol_logger_message))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).resource as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).message_opcode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(message_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).message as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).arguments_count as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(arguments_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_protocol_logger_message>())).arguments as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_protocol_logger_message),
            "::",
            stringify!(arguments)
        )
    );
}
pub type wl_protocol_logger_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_data: *mut ::std::os::raw::c_void,
        direction: wl_protocol_logger_type,
        message: *const wl_protocol_logger_message,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_protocol_logger {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wl_display_add_protocol_logger(
        display: *mut wl_display,
        arg1: wl_protocol_logger_func_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_protocol_logger;
}
extern "C" {
    pub fn wl_protocol_logger_destroy(logger: *mut wl_protocol_logger);
}
#[doc = " \\class wl_object"]
#[doc = ""]
#[doc = " \\brief A protocol object."]
#[doc = ""]
#[doc = " A `wl_object` is an opaque struct identifying the protocol object"]
#[doc = " underlying a `wl_proxy` or `wl_resource`."]
#[doc = ""]
#[doc = " \\note Functions accessing a `wl_object` are not normally used by client code."]
#[doc = " Clients should normally use the higher level interface generated by the"]
#[doc = " scanner to interact with compositor objects."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_object {
    pub interface: *const wl_interface,
    pub implementation: *const ::std::os::raw::c_void,
    pub id: u32,
}
#[test]
fn bindgen_test_layout_wl_object() {
    assert_eq!(
        ::std::mem::size_of::<wl_object>(),
        24usize,
        concat!("Size of: ", stringify!(wl_object))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_object>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_object))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_object>())).interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_object),
            "::",
            stringify!(interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_object>())).implementation as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_object),
            "::",
            stringify!(implementation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_object>())).id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_object),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_resource {
    pub object: wl_object,
    pub destroy: wl_resource_destroy_func_t,
    pub link: wl_list,
    pub destroy_signal: wl_signal,
    pub client: *mut wl_client,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_wl_resource() {
    assert_eq!(
        ::std::mem::size_of::<wl_resource>(),
        80usize,
        concat!("Size of: ", stringify!(wl_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).destroy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).destroy_signal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(destroy_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).client as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_resource>())).data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_resource),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn wl_client_add_resource(client: *mut wl_client, resource: *mut wl_resource) -> u32;
}
extern "C" {
    pub fn wl_client_add_object(
        client: *mut wl_client,
        interface: *const wl_interface,
        implementation: *const ::std::os::raw::c_void,
        id: u32,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_client_new_object(
        client: *mut wl_client,
        interface: *const wl_interface,
        implementation: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut wl_resource;
}
extern "C" {
    pub fn wl_display_add_global(
        display: *mut wl_display,
        interface: *const wl_interface,
        data: *mut ::std::os::raw::c_void,
        bind: wl_global_bind_func_t,
    ) -> *mut wl_global;
}
extern "C" {
    pub fn wl_display_remove_global(display: *mut wl_display, global: *mut wl_global);
}
#[doc = " @page page_wayland The wayland protocol"]
#[doc = " @section page_ifaces_wayland Interfaces"]
#[doc = " - @subpage page_iface_wl_display - core global object"]
#[doc = " - @subpage page_iface_wl_registry - global registry object"]
#[doc = " - @subpage page_iface_wl_callback - callback object"]
#[doc = " - @subpage page_iface_wl_compositor - the compositor singleton"]
#[doc = " - @subpage page_iface_wl_shm_pool - a shared memory pool"]
#[doc = " - @subpage page_iface_wl_shm - shared memory support"]
#[doc = " - @subpage page_iface_wl_buffer - content for a wl_surface"]
#[doc = " - @subpage page_iface_wl_data_offer - offer to transfer data"]
#[doc = " - @subpage page_iface_wl_data_source - offer to transfer data"]
#[doc = " - @subpage page_iface_wl_data_device - data transfer device"]
#[doc = " - @subpage page_iface_wl_data_device_manager - data transfer interface"]
#[doc = " - @subpage page_iface_wl_shell - create desktop-style surfaces"]
#[doc = " - @subpage page_iface_wl_shell_surface - desktop-style metadata interface"]
#[doc = " - @subpage page_iface_wl_surface - an onscreen surface"]
#[doc = " - @subpage page_iface_wl_seat - group of input devices"]
#[doc = " - @subpage page_iface_wl_pointer - pointer input device"]
#[doc = " - @subpage page_iface_wl_keyboard - keyboard input device"]
#[doc = " - @subpage page_iface_wl_touch - touchscreen input device"]
#[doc = " - @subpage page_iface_wl_output - compositor output region"]
#[doc = " - @subpage page_iface_wl_region - region interface"]
#[doc = " - @subpage page_iface_wl_subcompositor - sub-surface compositing"]
#[doc = " - @subpage page_iface_wl_subsurface - sub-surface interface to a wl_surface"]
#[doc = " @section page_copyright_wayland Copyright"]
#[doc = " <pre>"]
#[doc = ""]
#[doc = " Copyright  2008-2011 Kristian Hgsberg"]
#[doc = " Copyright  2010-2011 Intel Corporation"]
#[doc = " Copyright  2012-2013 Collabora, Ltd."]
#[doc = ""]
#[doc = " Permission is hereby granted, free of charge, to any person"]
#[doc = " obtaining a copy of this software and associated documentation files"]
#[doc = " (the \"Software\"), to deal in the Software without restriction,"]
#[doc = " including without limitation the rights to use, copy, modify, merge,"]
#[doc = " publish, distribute, sublicense, and/or sell copies of the Software,"]
#[doc = " and to permit persons to whom the Software is furnished to do so,"]
#[doc = " subject to the following conditions:"]
#[doc = ""]
#[doc = " The above copyright notice and this permission notice (including the"]
#[doc = " next paragraph) shall be included in all copies or substantial"]
#[doc = " portions of the Software."]
#[doc = ""]
#[doc = " THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,"]
#[doc = " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF"]
#[doc = " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND"]
#[doc = " NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS"]
#[doc = " BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN"]
#[doc = " ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN"]
#[doc = " CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE"]
#[doc = " SOFTWARE."]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_compositor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_manager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_region {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subcompositor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subsurface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch {
    _unused: [u8; 0],
}
extern "C" {
    pub static wl_display_interface: wl_interface;
}
extern "C" {
    pub static wl_registry_interface: wl_interface;
}
extern "C" {
    pub static wl_callback_interface: wl_interface;
}
extern "C" {
    pub static wl_compositor_interface: wl_interface;
}
extern "C" {
    pub static wl_shm_pool_interface: wl_interface;
}
extern "C" {
    pub static wl_shm_interface: wl_interface;
}
extern "C" {
    pub static wl_buffer_interface: wl_interface;
}
extern "C" {
    pub static wl_data_offer_interface: wl_interface;
}
extern "C" {
    pub static wl_data_source_interface: wl_interface;
}
extern "C" {
    pub static wl_data_device_interface: wl_interface;
}
extern "C" {
    pub static wl_data_device_manager_interface: wl_interface;
}
extern "C" {
    pub static wl_shell_interface: wl_interface;
}
extern "C" {
    pub static wl_shell_surface_interface: wl_interface;
}
extern "C" {
    pub static wl_surface_interface: wl_interface;
}
extern "C" {
    pub static wl_seat_interface: wl_interface;
}
extern "C" {
    pub static wl_pointer_interface: wl_interface;
}
extern "C" {
    pub static wl_keyboard_interface: wl_interface;
}
extern "C" {
    pub static wl_touch_interface: wl_interface;
}
extern "C" {
    pub static wl_output_interface: wl_interface;
}
extern "C" {
    pub static wl_region_interface: wl_interface;
}
extern "C" {
    pub static wl_subcompositor_interface: wl_interface;
}
extern "C" {
    pub static wl_subsurface_interface: wl_interface;
}
#[doc = " server couldn't find object"]
pub const wl_display_error_WL_DISPLAY_ERROR_INVALID_OBJECT: wl_display_error = 0;
#[doc = " method doesn't exist on the specified interface or malformed request"]
pub const wl_display_error_WL_DISPLAY_ERROR_INVALID_METHOD: wl_display_error = 1;
#[doc = " server is out of memory"]
pub const wl_display_error_WL_DISPLAY_ERROR_NO_MEMORY: wl_display_error = 2;
#[doc = " implementation error in compositor"]
pub const wl_display_error_WL_DISPLAY_ERROR_IMPLEMENTATION: wl_display_error = 3;
#[doc = " @ingroup iface_wl_display"]
#[doc = " global error values"]
#[doc = ""]
#[doc = " These errors are global and can be emitted in response to any"]
#[doc = " server request."]
pub type wl_display_error = u32;
#[doc = " @ingroup iface_wl_display"]
#[doc = " @struct wl_display_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_display_interface {
    #[doc = " asynchronous roundtrip"]
    #[doc = ""]
    #[doc = " The sync request asks the server to emit the 'done' event on"]
    #[doc = " the returned wl_callback object. Since requests are handled"]
    #[doc = " in-order and events are delivered in-order, this can be used as"]
    #[doc = " a barrier to ensure all previous requests and the resulting"]
    #[doc = " events have been handled."]
    #[doc = ""]
    #[doc = " The object returned by this request will be destroyed by the"]
    #[doc = " compositor after the callback is fired and as such the client"]
    #[doc = " must not attempt to use it after that point."]
    #[doc = ""]
    #[doc = " The callback_data passed in the callback is the event serial."]
    #[doc = " @param callback callback object for the sync request"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, callback: u32),
    >,
    #[doc = " get global registry object"]
    #[doc = ""]
    #[doc = " This request creates a registry object that allows the client"]
    #[doc = " to list and bind the global objects available from the"]
    #[doc = " compositor."]
    #[doc = ""]
    #[doc = " It should be noted that the server side resources consumed in"]
    #[doc = " response to a get_registry request can only be released when the"]
    #[doc = " client disconnects, not when the client side proxy is destroyed."]
    #[doc = " Therefore, clients should invoke get_registry as infrequently as"]
    #[doc = " possible to avoid wasting memory."]
    #[doc = " @param registry global registry object"]
    pub get_registry: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, registry: u32),
    >,
}
#[test]
fn bindgen_test_layout_wl_display_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_display_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_display_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_display_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_display_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_display_interface>())).sync as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_display_interface),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_display_interface>())).get_registry as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_display_interface),
            "::",
            stringify!(get_registry)
        )
    );
}
#[doc = " @ingroup iface_wl_registry"]
#[doc = " @struct wl_registry_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_registry_interface {
    #[doc = " bind an object to the display"]
    #[doc = ""]
    #[doc = " Binds a new, client-created object to the server using the"]
    #[doc = " specified name as the identifier."]
    #[doc = " @param name unique numeric name of the object"]
    #[doc = " @param interface name of the objects interface"]
    #[doc = " @param version version of the objects interface"]
    #[doc = " @param id bounded object"]
    pub bind: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            name: u32,
            interface: *const ::std::os::raw::c_char,
            version: u32,
            id: u32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_registry_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_registry_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_registry_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_registry_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_registry_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_registry_interface>())).bind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_registry_interface),
            "::",
            stringify!(bind)
        )
    );
}
#[doc = " @ingroup iface_wl_compositor"]
#[doc = " @struct wl_compositor_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_compositor_interface {
    #[doc = " create new surface"]
    #[doc = ""]
    #[doc = " Ask the compositor to create a new surface."]
    #[doc = " @param id the new surface"]
    pub create_surface: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " create new region"]
    #[doc = ""]
    #[doc = " Ask the compositor to create a new region."]
    #[doc = " @param id the new region"]
    pub create_region: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
}
#[test]
fn bindgen_test_layout_wl_compositor_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_compositor_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_compositor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_compositor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_compositor_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_compositor_interface>())).create_surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_compositor_interface),
            "::",
            stringify!(create_surface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_compositor_interface>())).create_region as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_compositor_interface),
            "::",
            stringify!(create_region)
        )
    );
}
#[doc = " @ingroup iface_wl_shm_pool"]
#[doc = " @struct wl_shm_pool_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_pool_interface {
    #[doc = " create a buffer from the pool"]
    #[doc = ""]
    #[doc = " Create a wl_buffer object from the pool."]
    #[doc = ""]
    #[doc = " The buffer is created offset bytes into the pool and has width"]
    #[doc = " and height as specified. The stride argument specifies the"]
    #[doc = " number of bytes from the beginning of one row to the beginning"]
    #[doc = " of the next. The format is the pixel format of the buffer and"]
    #[doc = " must be one of those advertised through the wl_shm.format event."]
    #[doc = ""]
    #[doc = " A buffer will keep a reference to the pool it was created from"]
    #[doc = " so it is valid to destroy the pool immediately after creating a"]
    #[doc = " buffer from it."]
    #[doc = " @param id buffer to create"]
    #[doc = " @param offset buffer byte offset within the pool"]
    #[doc = " @param width buffer width, in pixels"]
    #[doc = " @param height buffer height, in pixels"]
    #[doc = " @param stride number of bytes from the beginning of one row to the beginning of the next row"]
    #[doc = " @param format buffer pixel format"]
    pub create_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            offset: i32,
            width: i32,
            height: i32,
            stride: i32,
            format: u32,
        ),
    >,
    #[doc = " destroy the pool"]
    #[doc = ""]
    #[doc = " Destroy the shared memory pool."]
    #[doc = ""]
    #[doc = " The mmapped memory will be released when all buffers that have"]
    #[doc = " been created from this pool are gone."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " change the size of the pool mapping"]
    #[doc = ""]
    #[doc = " This request will cause the server to remap the backing memory"]
    #[doc = " for the pool from the file descriptor passed when the pool was"]
    #[doc = " created, but using the new size. This request can only be used"]
    #[doc = " to make the pool bigger."]
    #[doc = " @param size new size of the pool, in bytes"]
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, size: i32),
    >,
}
#[test]
fn bindgen_test_layout_wl_shm_pool_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_shm_pool_interface>(),
        24usize,
        concat!("Size of: ", stringify!(wl_shm_pool_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_shm_pool_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_shm_pool_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shm_pool_interface>())).create_buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shm_pool_interface),
            "::",
            stringify!(create_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_shm_pool_interface>())).destroy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shm_pool_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_shm_pool_interface>())).resize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shm_pool_interface),
            "::",
            stringify!(resize)
        )
    );
}
#[doc = " buffer format is not known"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_FORMAT: wl_shm_error = 0;
#[doc = " invalid size or stride during pool or buffer creation"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_STRIDE: wl_shm_error = 1;
#[doc = " mmapping the file descriptor failed"]
pub const wl_shm_error_WL_SHM_ERROR_INVALID_FD: wl_shm_error = 2;
#[doc = " @ingroup iface_wl_shm"]
#[doc = " wl_shm error values"]
#[doc = ""]
#[doc = " These errors can be emitted in response to wl_shm requests."]
pub type wl_shm_error = u32;
#[doc = " 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB8888: wl_shm_format = 0;
#[doc = " 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB8888: wl_shm_format = 1;
#[doc = " 8-bit color index format, [7:0] C"]
pub const wl_shm_format_WL_SHM_FORMAT_C8: wl_shm_format = 538982467;
#[doc = " 8-bit RGB format, [7:0] R:G:B 3:3:2"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB332: wl_shm_format = 943867730;
#[doc = " 8-bit BGR format, [7:0] B:G:R 2:3:3"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR233: wl_shm_format = 944916290;
#[doc = " 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB4444: wl_shm_format = 842093144;
#[doc = " 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR4444: wl_shm_format = 842089048;
#[doc = " 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX4444: wl_shm_format = 842094674;
#[doc = " 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX4444: wl_shm_format = 842094658;
#[doc = " 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB4444: wl_shm_format = 842093121;
#[doc = " 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR4444: wl_shm_format = 842089025;
#[doc = " 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA4444: wl_shm_format = 842088786;
#[doc = " 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA4444: wl_shm_format = 842088770;
#[doc = " 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB1555: wl_shm_format = 892424792;
#[doc = " 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR1555: wl_shm_format = 892420696;
#[doc = " 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX5551: wl_shm_format = 892426322;
#[doc = " 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX5551: wl_shm_format = 892426306;
#[doc = " 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB1555: wl_shm_format = 892424769;
#[doc = " 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR1555: wl_shm_format = 892420673;
#[doc = " 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA5551: wl_shm_format = 892420434;
#[doc = " 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA5551: wl_shm_format = 892420418;
#[doc = " 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB565: wl_shm_format = 909199186;
#[doc = " 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR565: wl_shm_format = 909199170;
#[doc = " 24-bit RGB format, [23:0] R:G:B little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB888: wl_shm_format = 875710290;
#[doc = " 24-bit BGR format, [23:0] B:G:R little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR888: wl_shm_format = 875710274;
#[doc = " 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR8888: wl_shm_format = 875709016;
#[doc = " 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX8888: wl_shm_format = 875714642;
#[doc = " 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX8888: wl_shm_format = 875714626;
#[doc = " 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR8888: wl_shm_format = 875708993;
#[doc = " 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA8888: wl_shm_format = 875708754;
#[doc = " 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA8888: wl_shm_format = 875708738;
#[doc = " 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB2101010: wl_shm_format = 808669784;
#[doc = " 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR2101010: wl_shm_format = 808665688;
#[doc = " 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX1010102: wl_shm_format = 808671314;
#[doc = " 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX1010102: wl_shm_format = 808671298;
#[doc = " 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB2101010: wl_shm_format = 808669761;
#[doc = " 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR2101010: wl_shm_format = 808665665;
#[doc = " 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBA1010102: wl_shm_format = 808665426;
#[doc = " 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRA1010102: wl_shm_format = 808665410;
#[doc = " packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUYV: wl_shm_format = 1448695129;
#[doc = " packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YVYU: wl_shm_format = 1431918169;
#[doc = " packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_UYVY: wl_shm_format = 1498831189;
#[doc = " packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_VYUY: wl_shm_format = 1498765654;
#[doc = " packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_AYUV: wl_shm_format = 1448433985;
#[doc = " 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV12: wl_shm_format = 842094158;
#[doc = " 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV21: wl_shm_format = 825382478;
#[doc = " 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV16: wl_shm_format = 909203022;
#[doc = " 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV61: wl_shm_format = 825644622;
#[doc = " 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV410: wl_shm_format = 961959257;
#[doc = " 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU410: wl_shm_format = 961893977;
#[doc = " 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV411: wl_shm_format = 825316697;
#[doc = " 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU411: wl_shm_format = 825316953;
#[doc = " 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420: wl_shm_format = 842093913;
#[doc = " 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU420: wl_shm_format = 842094169;
#[doc = " 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV422: wl_shm_format = 909202777;
#[doc = " 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU422: wl_shm_format = 909203033;
#[doc = " 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV444: wl_shm_format = 875713881;
#[doc = " 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes"]
pub const wl_shm_format_WL_SHM_FORMAT_YVU444: wl_shm_format = 875714137;
#[doc = " [7:0] R"]
pub const wl_shm_format_WL_SHM_FORMAT_R8: wl_shm_format = 538982482;
#[doc = " [15:0] R little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_R16: wl_shm_format = 540422482;
#[doc = " [15:0] R:G 8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RG88: wl_shm_format = 943212370;
#[doc = " [15:0] G:R 8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_GR88: wl_shm_format = 943215175;
#[doc = " [31:0] R:G 16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RG1616: wl_shm_format = 842221394;
#[doc = " [31:0] G:R 16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_GR1616: wl_shm_format = 842224199;
#[doc = " [63:0] x:R:G:B 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB16161616F: wl_shm_format = 1211388504;
#[doc = " [63:0] x:B:G:R 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR16161616F: wl_shm_format = 1211384408;
#[doc = " [63:0] A:R:G:B 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ARGB16161616F: wl_shm_format = 1211388481;
#[doc = " [63:0] A:B:G:R 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_ABGR16161616F: wl_shm_format = 1211384385;
#[doc = " [31:0] X:Y:Cb:Cr 8:8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XYUV8888: wl_shm_format = 1448434008;
#[doc = " [23:0] Cr:Cb:Y 8:8:8 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_VUY888: wl_shm_format = 875713878;
#[doc = " Y followed by U then V, 10:10:10. Non-linear modifier only"]
pub const wl_shm_format_WL_SHM_FORMAT_VUY101010: wl_shm_format = 808670550;
#[doc = " [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y210: wl_shm_format = 808530521;
#[doc = " [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y212: wl_shm_format = 842084953;
#[doc = " [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels"]
pub const wl_shm_format_WL_SHM_FORMAT_Y216: wl_shm_format = 909193817;
#[doc = " [31:0] A:Cr:Y:Cb 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y410: wl_shm_format = 808531033;
#[doc = " [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y412: wl_shm_format = 842085465;
#[doc = " [63:0] A:Cr:Y:Cb 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y416: wl_shm_format = 909194329;
#[doc = " [31:0] X:Cr:Y:Cb 2:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU2101010: wl_shm_format = 808670808;
#[doc = " [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU12_16161616: wl_shm_format = 909334104;
#[doc = " [63:0] X:Cr:Y:Cb 16:16:16:16 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XVYU16161616: wl_shm_format = 942954072;
#[doc = " [63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y0L0: wl_shm_format = 810299481;
#[doc = " [63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_X0L0: wl_shm_format = 810299480;
#[doc = " [63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_Y0L2: wl_shm_format = 843853913;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_X0L2: wl_shm_format = 843853912;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420_8BIT: wl_shm_format = 942691673;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_YUV420_10BIT: wl_shm_format = 808539481;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XRGB8888_A8: wl_shm_format = 943805016;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_XBGR8888_A8: wl_shm_format = 943800920;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGBX8888_A8: wl_shm_format = 943806546;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGRX8888_A8: wl_shm_format = 943806530;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB888_A8: wl_shm_format = 943798354;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR888_A8: wl_shm_format = 943798338;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_RGB565_A8: wl_shm_format = 943797586;
#[doc = " [63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian"]
pub const wl_shm_format_WL_SHM_FORMAT_BGR565_A8: wl_shm_format = 943797570;
#[doc = " non-subsampled Cr:Cb plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV24: wl_shm_format = 875714126;
#[doc = " non-subsampled Cb:Cr plane"]
pub const wl_shm_format_WL_SHM_FORMAT_NV42: wl_shm_format = 842290766;
#[doc = " 2x1 subsampled Cr:Cb plane, 10 bit per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P210: wl_shm_format = 808530512;
#[doc = " 2x2 subsampled Cr:Cb plane 10 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P010: wl_shm_format = 808530000;
#[doc = " 2x2 subsampled Cr:Cb plane 12 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P012: wl_shm_format = 842084432;
#[doc = " 2x2 subsampled Cr:Cb plane 16 bits per channel"]
pub const wl_shm_format_WL_SHM_FORMAT_P016: wl_shm_format = 909193296;
#[doc = " @ingroup iface_wl_shm"]
#[doc = " pixel formats"]
#[doc = ""]
#[doc = " This describes the memory layout of an individual pixel."]
#[doc = ""]
#[doc = " All renderers should support argb8888 and xrgb8888 but any other"]
#[doc = " formats are optional and may not be supported by the particular"]
#[doc = " renderer in use."]
#[doc = ""]
#[doc = " The drm format codes match the macros defined in drm_fourcc.h, except"]
#[doc = " argb8888 and xrgb8888. The formats actually supported by the compositor"]
#[doc = " will be reported by the format event."]
pub type wl_shm_format = u32;
#[doc = " @ingroup iface_wl_shm"]
#[doc = " @struct wl_shm_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shm_interface {
    #[doc = " create a shm pool"]
    #[doc = ""]
    #[doc = " Create a new wl_shm_pool object."]
    #[doc = ""]
    #[doc = " The pool can be used to create shared memory based buffer"]
    #[doc = " objects. The server will mmap size bytes of the passed file"]
    #[doc = " descriptor, to use as backing memory for the pool."]
    #[doc = " @param id pool to create"]
    #[doc = " @param fd file descriptor for the pool"]
    #[doc = " @param size pool size, in bytes"]
    pub create_pool: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            fd: i32,
            size: i32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_shm_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_shm_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_shm_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_shm_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_shm_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_shm_interface>())).create_pool as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shm_interface),
            "::",
            stringify!(create_pool)
        )
    );
}
#[doc = " @ingroup iface_wl_buffer"]
#[doc = " @struct wl_buffer_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_buffer_interface {
    #[doc = " destroy a buffer"]
    #[doc = ""]
    #[doc = " Destroy a buffer. If and how you need to release the backing"]
    #[doc = " storage is defined by the buffer factory interface."]
    #[doc = ""]
    #[doc = " For possible side-effects to a surface, see wl_surface.attach."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_buffer_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_buffer_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_buffer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_buffer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_buffer_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_buffer_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_buffer_interface),
            "::",
            stringify!(destroy)
        )
    );
}
#[doc = " finish request was called untimely"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_FINISH: wl_data_offer_error = 0;
#[doc = " action mask contains invalid values"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK: wl_data_offer_error = 1;
#[doc = " action argument has an invalid value"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_ACTION: wl_data_offer_error = 2;
#[doc = " offer doesn't accept this request"]
pub const wl_data_offer_error_WL_DATA_OFFER_ERROR_INVALID_OFFER: wl_data_offer_error = 3;
pub type wl_data_offer_error = u32;
#[doc = " @ingroup iface_wl_data_offer"]
#[doc = " @struct wl_data_offer_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_offer_interface {
    #[doc = " accept one of the offered mime types"]
    #[doc = ""]
    #[doc = " Indicate that the client can accept the given mime type, or"]
    #[doc = " NULL for not accepted."]
    #[doc = ""]
    #[doc = " For objects of version 2 or older, this request is used by the"]
    #[doc = " client to give feedback whether the client can receive the given"]
    #[doc = " mime type, or NULL if none is accepted; the feedback does not"]
    #[doc = " determine whether the drag-and-drop operation succeeds or not."]
    #[doc = ""]
    #[doc = " For objects of version 3 or newer, this request determines the"]
    #[doc = " final result of the drag-and-drop operation. If the end result"]
    #[doc = " is that no mime types were accepted, the drag-and-drop operation"]
    #[doc = " will be cancelled and the corresponding drag source will receive"]
    #[doc = " wl_data_source.cancelled. Clients may still use this event in"]
    #[doc = " conjunction with wl_data_source.action for feedback."]
    #[doc = " @param serial serial number of the accept request"]
    #[doc = " @param mime_type mime type accepted by the client"]
    pub accept: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            serial: u32,
            mime_type: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " request that the data is transferred"]
    #[doc = ""]
    #[doc = " To transfer the offered data, the client issues this request"]
    #[doc = " and indicates the mime type it wants to receive. The transfer"]
    #[doc = " happens through the passed file descriptor (typically created"]
    #[doc = " with the pipe system call). The source client writes the data in"]
    #[doc = " the mime type representation requested and then closes the file"]
    #[doc = " descriptor."]
    #[doc = ""]
    #[doc = " The receiving client reads from the read end of the pipe until"]
    #[doc = " EOF and then closes its end, at which point the transfer is"]
    #[doc = " complete."]
    #[doc = ""]
    #[doc = " This request may happen multiple times for different mime types,"]
    #[doc = " both before and after wl_data_device.drop. Drag-and-drop"]
    #[doc = " destination clients may preemptively fetch data or examine it"]
    #[doc = " more closely to determine acceptance."]
    #[doc = " @param mime_type mime type desired by receiver"]
    #[doc = " @param fd file descriptor for data transfer"]
    pub receive: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            mime_type: *const ::std::os::raw::c_char,
            fd: i32,
        ),
    >,
    #[doc = " destroy data offer"]
    #[doc = ""]
    #[doc = " Destroy the data offer."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " the offer will no longer be used"]
    #[doc = ""]
    #[doc = " Notifies the compositor that the drag destination successfully"]
    #[doc = " finished the drag-and-drop operation."]
    #[doc = ""]
    #[doc = " Upon receiving this request, the compositor will emit"]
    #[doc = " wl_data_source.dnd_finished on the drag source client."]
    #[doc = ""]
    #[doc = " It is a client error to perform other requests than"]
    #[doc = " wl_data_offer.destroy after this one. It is also an error to"]
    #[doc = " perform this request after a NULL mime type has been set in"]
    #[doc = " wl_data_offer.accept or no action was received through"]
    #[doc = " wl_data_offer.action."]
    #[doc = ""]
    #[doc = " If wl_data_offer.finish request is received for a non drag and"]
    #[doc = " drop operation, the invalid_finish protocol error is raised."]
    #[doc = " @since 3"]
    pub finish: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the available/preferred drag-and-drop actions"]
    #[doc = ""]
    #[doc = " Sets the actions that the destination side client supports for"]
    #[doc = " this operation. This request may trigger the emission of"]
    #[doc = " wl_data_source.action and wl_data_offer.action events if the"]
    #[doc = " compositor needs to change the selected action."]
    #[doc = ""]
    #[doc = " This request can be called multiple times throughout the"]
    #[doc = " drag-and-drop operation, typically in response to"]
    #[doc = " wl_data_device.enter or wl_data_device.motion events."]
    #[doc = ""]
    #[doc = " This request determines the final result of the drag-and-drop"]
    #[doc = " operation. If the end result is that no action is accepted, the"]
    #[doc = " drag source will receive wl_data_source.cancelled."]
    #[doc = ""]
    #[doc = " The dnd_actions argument must contain only values expressed in"]
    #[doc = " the wl_data_device_manager.dnd_actions enum, and the"]
    #[doc = " preferred_action argument must only contain one of those values"]
    #[doc = " set, otherwise it will result in a protocol error."]
    #[doc = ""]
    #[doc = " While managing an \"ask\" action, the destination drag-and-drop"]
    #[doc = " client may perform further wl_data_offer.receive requests, and"]
    #[doc = " is expected to perform one last wl_data_offer.set_actions"]
    #[doc = " request with a preferred action other than \"ask\" (and optionally"]
    #[doc = " wl_data_offer.accept) before requesting wl_data_offer.finish, in"]
    #[doc = " order to convey the action selected by the user. If the"]
    #[doc = " preferred action is not in the wl_data_offer.source_actions"]
    #[doc = " mask, an error will be raised."]
    #[doc = ""]
    #[doc = " If the \"ask\" action is dismissed (e.g. user cancellation), the"]
    #[doc = " client is expected to perform wl_data_offer.destroy right away."]
    #[doc = ""]
    #[doc = " This request can only be made on drag-and-drop offers, a"]
    #[doc = " protocol error will be raised otherwise."]
    #[doc = " @param dnd_actions actions supported by the destination client"]
    #[doc = " @param preferred_action action preferred by the destination client"]
    #[doc = " @since 3"]
    pub set_actions: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            dnd_actions: u32,
            preferred_action: u32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_data_offer_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_data_offer_interface>(),
        40usize,
        concat!("Size of: ", stringify!(wl_data_offer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_data_offer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_data_offer_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_offer_interface>())).accept as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(accept)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_offer_interface>())).receive as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(receive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_offer_interface>())).destroy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_offer_interface>())).finish as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_offer_interface>())).set_actions as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_offer_interface),
            "::",
            stringify!(set_actions)
        )
    );
}
#[doc = " action mask contains invalid values"]
pub const wl_data_source_error_WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK: wl_data_source_error = 0;
#[doc = " source doesn't accept this request"]
pub const wl_data_source_error_WL_DATA_SOURCE_ERROR_INVALID_SOURCE: wl_data_source_error = 1;
pub type wl_data_source_error = u32;
#[doc = " @ingroup iface_wl_data_source"]
#[doc = " @struct wl_data_source_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_source_interface {
    #[doc = " add an offered mime type"]
    #[doc = ""]
    #[doc = " This request adds a mime type to the set of mime types"]
    #[doc = " advertised to targets. Can be called several times to offer"]
    #[doc = " multiple types."]
    #[doc = " @param mime_type mime type offered by the data source"]
    pub offer: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            mime_type: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " destroy the data source"]
    #[doc = ""]
    #[doc = " Destroy the data source."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the available drag-and-drop actions"]
    #[doc = ""]
    #[doc = " Sets the actions that the source side client supports for this"]
    #[doc = " operation. This request may trigger wl_data_source.action and"]
    #[doc = " wl_data_offer.action events if the compositor needs to change"]
    #[doc = " the selected action."]
    #[doc = ""]
    #[doc = " The dnd_actions argument must contain only values expressed in"]
    #[doc = " the wl_data_device_manager.dnd_actions enum, otherwise it will"]
    #[doc = " result in a protocol error."]
    #[doc = ""]
    #[doc = " This request must be made once only, and can only be made on"]
    #[doc = " sources used in drag-and-drop, so it must be performed before"]
    #[doc = " wl_data_device.start_drag. Attempting to use the source other"]
    #[doc = " than for drag-and-drop will raise a protocol error."]
    #[doc = " @param dnd_actions actions supported by the data source"]
    #[doc = " @since 3"]
    pub set_actions: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, dnd_actions: u32),
    >,
}
#[test]
fn bindgen_test_layout_wl_data_source_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_data_source_interface>(),
        24usize,
        concat!("Size of: ", stringify!(wl_data_source_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_data_source_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_data_source_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_data_source_interface>())).offer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_source_interface),
            "::",
            stringify!(offer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_source_interface>())).destroy as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_source_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_source_interface>())).set_actions as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_source_interface),
            "::",
            stringify!(set_actions)
        )
    );
}
#[doc = " given wl_surface has another role"]
pub const wl_data_device_error_WL_DATA_DEVICE_ERROR_ROLE: wl_data_device_error = 0;
pub type wl_data_device_error = u32;
#[doc = " @ingroup iface_wl_data_device"]
#[doc = " @struct wl_data_device_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_interface {
    #[doc = " start drag-and-drop operation"]
    #[doc = ""]
    #[doc = " This request asks the compositor to start a drag-and-drop"]
    #[doc = " operation on behalf of the client."]
    #[doc = ""]
    #[doc = " The source argument is the data source that provides the data"]
    #[doc = " for the eventual data transfer. If source is NULL, enter, leave"]
    #[doc = " and motion events are sent only to the client that initiated the"]
    #[doc = " drag and the client is expected to handle the data passing"]
    #[doc = " internally."]
    #[doc = ""]
    #[doc = " The origin surface is the surface where the drag originates and"]
    #[doc = " the client must have an active implicit grab that matches the"]
    #[doc = " serial."]
    #[doc = ""]
    #[doc = " The icon surface is an optional (can be NULL) surface that"]
    #[doc = " provides an icon to be moved around with the cursor. Initially,"]
    #[doc = " the top-left corner of the icon surface is placed at the cursor"]
    #[doc = " hotspot, but subsequent wl_surface.attach request can move the"]
    #[doc = " relative position. Attach requests must be confirmed with"]
    #[doc = " wl_surface.commit as usual. The icon surface is given the role"]
    #[doc = " of a drag-and-drop icon. If the icon surface already has another"]
    #[doc = " role, it raises a protocol error."]
    #[doc = ""]
    #[doc = " The current and pending input regions of the icon wl_surface are"]
    #[doc = " cleared, and wl_surface.set_input_region is ignored until the"]
    #[doc = " wl_surface is no longer used as the icon surface. When the use"]
    #[doc = " as an icon ends, the current and pending input regions become"]
    #[doc = " undefined, and the wl_surface is unmapped."]
    #[doc = " @param source data source for the eventual transfer"]
    #[doc = " @param origin surface where the drag originates"]
    #[doc = " @param icon drag-and-drop icon surface"]
    #[doc = " @param serial serial number of the implicit grab on the origin"]
    pub start_drag: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            source: *mut wl_resource,
            origin: *mut wl_resource,
            icon: *mut wl_resource,
            serial: u32,
        ),
    >,
    #[doc = " copy data to the selection"]
    #[doc = ""]
    #[doc = " This request asks the compositor to set the selection to the"]
    #[doc = " data from the source on behalf of the client."]
    #[doc = ""]
    #[doc = " To unset the selection, set the source to NULL."]
    #[doc = " @param source data source for the selection"]
    #[doc = " @param serial serial number of the event that triggered this request"]
    pub set_selection: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            source: *mut wl_resource,
            serial: u32,
        ),
    >,
    #[doc = " destroy data device"]
    #[doc = ""]
    #[doc = " This request destroys the data device."]
    #[doc = " @since 2"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_data_device_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_data_device_interface>(),
        24usize,
        concat!("Size of: ", stringify!(wl_data_device_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_data_device_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_data_device_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_interface>())).start_drag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_interface),
            "::",
            stringify!(start_drag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_interface>())).set_selection as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_interface),
            "::",
            stringify!(set_selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_interface>())).release as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_interface),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " no action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE:
    wl_data_device_manager_dnd_action = 0;
#[doc = " copy action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY:
    wl_data_device_manager_dnd_action = 1;
#[doc = " move action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE:
    wl_data_device_manager_dnd_action = 2;
#[doc = " ask action"]
pub const wl_data_device_manager_dnd_action_WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK:
    wl_data_device_manager_dnd_action = 4;
#[doc = " @ingroup iface_wl_data_device_manager"]
#[doc = " drag and drop actions"]
#[doc = ""]
#[doc = " This is a bitmask of the available/preferred actions in a"]
#[doc = " drag-and-drop operation."]
#[doc = ""]
#[doc = " In the compositor, the selected action is a result of matching the"]
#[doc = " actions offered by the source and destination sides.  \"action\" events"]
#[doc = " with a \"none\" action will be sent to both source and destination if"]
#[doc = " there is no match. All further checks will effectively happen on"]
#[doc = " (source actions  destination actions)."]
#[doc = ""]
#[doc = " In addition, compositors may also pick different actions in"]
#[doc = " reaction to key modifiers being pressed. One common design that"]
#[doc = " is used in major toolkits (and the behavior recommended for"]
#[doc = " compositors) is:"]
#[doc = ""]
#[doc = " - If no modifiers are pressed, the first match (in bit order)"]
#[doc = " will be used."]
#[doc = " - Pressing Shift selects \"move\", if enabled in the mask."]
#[doc = " - Pressing Control selects \"copy\", if enabled in the mask."]
#[doc = ""]
#[doc = " Behavior beyond that is considered implementation-dependent."]
#[doc = " Compositors may for example bind other modifiers (like Alt/Meta)"]
#[doc = " or drags initiated with other buttons than BTN_LEFT to specific"]
#[doc = " actions (e.g. \"ask\")."]
pub type wl_data_device_manager_dnd_action = u32;
#[doc = " @ingroup iface_wl_data_device_manager"]
#[doc = " @struct wl_data_device_manager_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_data_device_manager_interface {
    #[doc = " create a new data source"]
    #[doc = ""]
    #[doc = " Create a new data source."]
    #[doc = " @param id data source to create"]
    pub create_data_source: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " create a new data device"]
    #[doc = ""]
    #[doc = " Create a new data device for a given seat."]
    #[doc = " @param id data device to create"]
    #[doc = " @param seat seat associated with the data device"]
    pub get_data_device: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            seat: *mut wl_resource,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_data_device_manager_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_data_device_manager_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_data_device_manager_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_data_device_manager_interface>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(wl_data_device_manager_interface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_manager_interface>())).create_data_source
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_manager_interface),
            "::",
            stringify!(create_data_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_data_device_manager_interface>())).get_data_device as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_data_device_manager_interface),
            "::",
            stringify!(get_data_device)
        )
    );
}
#[doc = " given wl_surface has another role"]
pub const wl_shell_error_WL_SHELL_ERROR_ROLE: wl_shell_error = 0;
pub type wl_shell_error = u32;
#[doc = " @ingroup iface_wl_shell"]
#[doc = " @struct wl_shell_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_interface {
    #[doc = " create a shell surface from a surface"]
    #[doc = ""]
    #[doc = " Create a shell surface for an existing surface. This gives the"]
    #[doc = " wl_surface the role of a shell surface. If the wl_surface"]
    #[doc = " already has another role, it raises a protocol error."]
    #[doc = ""]
    #[doc = " Only one shell surface can be associated with a given surface."]
    #[doc = " @param id shell surface to create"]
    #[doc = " @param surface surface to be given the shell surface role"]
    pub get_shell_surface: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            surface: *mut wl_resource,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_shell_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_shell_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_shell_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_shell_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_shell_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_interface>())).get_shell_surface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_interface),
            "::",
            stringify!(get_shell_surface)
        )
    );
}
#[doc = " no edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_NONE: wl_shell_surface_resize = 0;
#[doc = " top edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP: wl_shell_surface_resize = 1;
#[doc = " bottom edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM: wl_shell_surface_resize = 2;
#[doc = " left edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_LEFT: wl_shell_surface_resize = 4;
#[doc = " top and left edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP_LEFT: wl_shell_surface_resize = 5;
#[doc = " bottom and left edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT: wl_shell_surface_resize = 6;
#[doc = " right edge"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_RIGHT: wl_shell_surface_resize = 8;
#[doc = " top and right edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_TOP_RIGHT: wl_shell_surface_resize = 9;
#[doc = " bottom and right edges"]
pub const wl_shell_surface_resize_WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT: wl_shell_surface_resize =
    10;
#[doc = " @ingroup iface_wl_shell_surface"]
#[doc = " edge values for resizing"]
#[doc = ""]
#[doc = " These values are used to indicate which edge of a surface"]
#[doc = " is being dragged in a resize operation. The server may"]
#[doc = " use this information to adapt its behavior, e.g. choose"]
#[doc = " an appropriate cursor image."]
pub type wl_shell_surface_resize = u32;
#[doc = " do not set keyboard focus"]
pub const wl_shell_surface_transient_WL_SHELL_SURFACE_TRANSIENT_INACTIVE:
    wl_shell_surface_transient = 1;
#[doc = " @ingroup iface_wl_shell_surface"]
#[doc = " details of transient behaviour"]
#[doc = ""]
#[doc = " These flags specify details of the expected behaviour"]
#[doc = " of transient surfaces. Used in the set_transient request."]
pub type wl_shell_surface_transient = u32;
#[doc = " no preference, apply default policy"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT:
    wl_shell_surface_fullscreen_method = 0;
#[doc = " scale, preserve the surface's aspect ratio and center on output"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE:
    wl_shell_surface_fullscreen_method = 1;
#[doc = " switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER:
    wl_shell_surface_fullscreen_method = 2;
#[doc = " no upscaling, center on output and add black borders to compensate size mismatch"]
pub const wl_shell_surface_fullscreen_method_WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL:
    wl_shell_surface_fullscreen_method = 3;
#[doc = " @ingroup iface_wl_shell_surface"]
#[doc = " different method to set the surface fullscreen"]
#[doc = ""]
#[doc = " Hints to indicate to the compositor how to deal with a conflict"]
#[doc = " between the dimensions of the surface and the dimensions of the"]
#[doc = " output. The compositor is free to ignore this parameter."]
pub type wl_shell_surface_fullscreen_method = u32;
#[doc = " @ingroup iface_wl_shell_surface"]
#[doc = " @struct wl_shell_surface_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_shell_surface_interface {
    #[doc = " respond to a ping event"]
    #[doc = ""]
    #[doc = " A client must respond to a ping event with a pong request or"]
    #[doc = " the client may be deemed unresponsive."]
    #[doc = " @param serial serial number of the ping event"]
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, serial: u32),
    >,
    #[doc = " start an interactive move"]
    #[doc = ""]
    #[doc = " Start a pointer-driven move of the surface."]
    #[doc = ""]
    #[doc = " This request must be used in response to a button press event."]
    #[doc = " The server may ignore move requests depending on the state of"]
    #[doc = " the surface (e.g. fullscreen or maximized)."]
    #[doc = " @param seat seat whose pointer is used"]
    #[doc = " @param serial serial number of the implicit grab on the pointer"]
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
        ),
    >,
    #[doc = " start an interactive resize"]
    #[doc = ""]
    #[doc = " Start a pointer-driven resizing of the surface."]
    #[doc = ""]
    #[doc = " This request must be used in response to a button press event."]
    #[doc = " The server may ignore resize requests depending on the state of"]
    #[doc = " the surface (e.g. fullscreen or maximized)."]
    #[doc = " @param seat seat whose pointer is used"]
    #[doc = " @param serial serial number of the implicit grab on the pointer"]
    #[doc = " @param edges which edge or corner is being dragged"]
    pub resize: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
            edges: u32,
        ),
    >,
    #[doc = " make the surface a toplevel surface"]
    #[doc = ""]
    #[doc = " Map the surface as a toplevel surface."]
    #[doc = ""]
    #[doc = " A toplevel surface is not fullscreen, maximized or transient."]
    pub set_toplevel: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " make the surface a transient surface"]
    #[doc = ""]
    #[doc = " Map the surface relative to an existing surface."]
    #[doc = ""]
    #[doc = " The x and y arguments specify the location of the upper left"]
    #[doc = " corner of the surface relative to the upper left corner of the"]
    #[doc = " parent surface, in surface-local coordinates."]
    #[doc = ""]
    #[doc = " The flags argument controls details of the transient behaviour."]
    #[doc = " @param parent parent surface"]
    #[doc = " @param x surface-local x coordinate"]
    #[doc = " @param y surface-local y coordinate"]
    #[doc = " @param flags transient surface behavior"]
    pub set_transient: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            parent: *mut wl_resource,
            x: i32,
            y: i32,
            flags: u32,
        ),
    >,
    #[doc = " make the surface a fullscreen surface"]
    #[doc = ""]
    #[doc = " Map the surface as a fullscreen surface."]
    #[doc = ""]
    #[doc = " If an output parameter is given then the surface will be made"]
    #[doc = " fullscreen on that output. If the client does not specify the"]
    #[doc = " output then the compositor will apply its policy - usually"]
    #[doc = " choosing the output on which the surface has the biggest surface"]
    #[doc = " area."]
    #[doc = ""]
    #[doc = " The client may specify a method to resolve a size conflict"]
    #[doc = " between the output size and the surface size - this is provided"]
    #[doc = " through the method parameter."]
    #[doc = ""]
    #[doc = " The framerate parameter is used only when the method is set to"]
    #[doc = " \"driver\", to indicate the preferred framerate. A value of 0"]
    #[doc = " indicates that the client does not care about framerate. The"]
    #[doc = " framerate is specified in mHz, that is framerate of 60000 is"]
    #[doc = " 60Hz."]
    #[doc = ""]
    #[doc = " A method of \"scale\" or \"driver\" implies a scaling operation of"]
    #[doc = " the surface, either via a direct scaling operation or a change"]
    #[doc = " of the output mode. This will override any kind of output"]
    #[doc = " scaling, so that mapping a surface with a buffer size equal to"]
    #[doc = " the mode can fill the screen independent of buffer_scale."]
    #[doc = ""]
    #[doc = " A method of \"fill\" means we don't scale up the buffer, however"]
    #[doc = " any output scale is applied. This means that you may run into an"]
    #[doc = " edge case where the application maps a buffer with the same size"]
    #[doc = " of the output mode but buffer_scale 1 (thus making a surface"]
    #[doc = " larger than the output). In this case it is allowed to downscale"]
    #[doc = " the results to fit the screen."]
    #[doc = ""]
    #[doc = " The compositor must reply to this request with a configure event"]
    #[doc = " with the dimensions for the output on which the surface will be"]
    #[doc = " made fullscreen."]
    #[doc = " @param method method for resolving size conflict"]
    #[doc = " @param framerate framerate in mHz"]
    #[doc = " @param output output on which the surface is to be fullscreen"]
    pub set_fullscreen: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            method: u32,
            framerate: u32,
            output: *mut wl_resource,
        ),
    >,
    #[doc = " make the surface a popup surface"]
    #[doc = ""]
    #[doc = " Map the surface as a popup."]
    #[doc = ""]
    #[doc = " A popup surface is a transient surface with an added pointer"]
    #[doc = " grab."]
    #[doc = ""]
    #[doc = " An existing implicit grab will be changed to owner-events mode,"]
    #[doc = " and the popup grab will continue after the implicit grab ends"]
    #[doc = " (i.e. releasing the mouse button does not cause the popup to be"]
    #[doc = " unmapped)."]
    #[doc = ""]
    #[doc = " The popup grab continues until the window is destroyed or a"]
    #[doc = " mouse button is pressed in any other client's window. A click in"]
    #[doc = " any of the client's surfaces is reported as normal, however,"]
    #[doc = " clicks in other clients' surfaces will be discarded and trigger"]
    #[doc = " the callback."]
    #[doc = ""]
    #[doc = " The x and y arguments specify the location of the upper left"]
    #[doc = " corner of the surface relative to the upper left corner of the"]
    #[doc = " parent surface, in surface-local coordinates."]
    #[doc = " @param seat seat whose pointer is used"]
    #[doc = " @param serial serial number of the implicit grab on the pointer"]
    #[doc = " @param parent parent surface"]
    #[doc = " @param x surface-local x coordinate"]
    #[doc = " @param y surface-local y coordinate"]
    #[doc = " @param flags transient surface behavior"]
    pub set_popup: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            seat: *mut wl_resource,
            serial: u32,
            parent: *mut wl_resource,
            x: i32,
            y: i32,
            flags: u32,
        ),
    >,
    #[doc = " make the surface a maximized surface"]
    #[doc = ""]
    #[doc = " Map the surface as a maximized surface."]
    #[doc = ""]
    #[doc = " If an output parameter is given then the surface will be"]
    #[doc = " maximized on that output. If the client does not specify the"]
    #[doc = " output then the compositor will apply its policy - usually"]
    #[doc = " choosing the output on which the surface has the biggest surface"]
    #[doc = " area."]
    #[doc = ""]
    #[doc = " The compositor will reply with a configure event telling the"]
    #[doc = " expected new surface size. The operation is completed on the"]
    #[doc = " next buffer attach to this surface."]
    #[doc = ""]
    #[doc = " A maximized surface typically fills the entire output it is"]
    #[doc = " bound to, except for desktop elements such as panels. This is"]
    #[doc = " the main difference between a maximized shell surface and a"]
    #[doc = " fullscreen shell surface."]
    #[doc = ""]
    #[doc = " The details depend on the compositor implementation."]
    #[doc = " @param output output on which the surface is to be maximized"]
    pub set_maximized: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            output: *mut wl_resource,
        ),
    >,
    #[doc = " set surface title"]
    #[doc = ""]
    #[doc = " Set a short title for the surface."]
    #[doc = ""]
    #[doc = " This string may be used to identify the surface in a task bar,"]
    #[doc = " window list, or other user interface elements provided by the"]
    #[doc = " compositor."]
    #[doc = ""]
    #[doc = " The string must be encoded in UTF-8."]
    #[doc = " @param title surface title"]
    pub set_title: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            title: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " set surface class"]
    #[doc = ""]
    #[doc = " Set a class for the surface."]
    #[doc = ""]
    #[doc = " The surface class identifies the general class of applications"]
    #[doc = " to which the surface belongs. A common convention is to use the"]
    #[doc = " file name (or the full path if it is a non-standard location) of"]
    #[doc = " the application's .desktop file as the class."]
    #[doc = " @param class_ surface class"]
    pub set_class: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            class_: *const ::std::os::raw::c_char,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_shell_surface_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_shell_surface_interface>(),
        80usize,
        concat!("Size of: ", stringify!(wl_shell_surface_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_shell_surface_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_shell_surface_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_shell_surface_interface>())).pong as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(pong)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).move_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).resize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_toplevel as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_toplevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_transient as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_transient)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_fullscreen as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_fullscreen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_popup as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_popup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_maximized as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_maximized)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_title as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_title)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_shell_surface_interface>())).set_class as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_shell_surface_interface),
            "::",
            stringify!(set_class)
        )
    );
}
#[doc = " buffer scale value is invalid"]
pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_SCALE: wl_surface_error = 0;
#[doc = " buffer transform value is invalid"]
pub const wl_surface_error_WL_SURFACE_ERROR_INVALID_TRANSFORM: wl_surface_error = 1;
#[doc = " @ingroup iface_wl_surface"]
#[doc = " wl_surface error values"]
#[doc = ""]
#[doc = " These errors can be emitted in response to wl_surface requests."]
pub type wl_surface_error = u32;
#[doc = " @ingroup iface_wl_surface"]
#[doc = " @struct wl_surface_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_surface_interface {
    #[doc = " delete surface"]
    #[doc = ""]
    #[doc = " Deletes the surface and invalidates its object ID."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set the surface contents"]
    #[doc = ""]
    #[doc = " Set a buffer as the content of this surface."]
    #[doc = ""]
    #[doc = " The new size of the surface is calculated based on the buffer"]
    #[doc = " size transformed by the inverse buffer_transform and the inverse"]
    #[doc = " buffer_scale. This means that the supplied buffer must be an"]
    #[doc = " integer multiple of the buffer_scale."]
    #[doc = ""]
    #[doc = " The x and y arguments specify the location of the new pending"]
    #[doc = " buffer's upper left corner, relative to the current buffer's"]
    #[doc = " upper left corner, in surface-local coordinates. In other words,"]
    #[doc = " the x and y, combined with the new surface size define in which"]
    #[doc = " directions the surface's size changes."]
    #[doc = ""]
    #[doc = " Surface contents are double-buffered state, see"]
    #[doc = " wl_surface.commit."]
    #[doc = ""]
    #[doc = " The initial surface contents are void; there is no content."]
    #[doc = " wl_surface.attach assigns the given wl_buffer as the pending"]
    #[doc = " wl_buffer. wl_surface.commit makes the pending wl_buffer the new"]
    #[doc = " surface contents, and the size of the surface becomes the size"]
    #[doc = " calculated from the wl_buffer, as described above. After commit,"]
    #[doc = " there is no pending buffer until the next attach."]
    #[doc = ""]
    #[doc = " Committing a pending wl_buffer allows the compositor to read the"]
    #[doc = " pixels in the wl_buffer. The compositor may access the pixels at"]
    #[doc = " any time after the wl_surface.commit request. When the"]
    #[doc = " compositor will not access the pixels anymore, it will send the"]
    #[doc = " wl_buffer.release event. Only after receiving wl_buffer.release,"]
    #[doc = " the client may reuse the wl_buffer. A wl_buffer that has been"]
    #[doc = " attached and then replaced by another attach instead of"]
    #[doc = " committed will not receive a release event, and is not used by"]
    #[doc = " the compositor."]
    #[doc = ""]
    #[doc = " If a pending wl_buffer has been committed to more than one"]
    #[doc = " wl_surface, the delivery of wl_buffer.release events becomes"]
    #[doc = " undefined. A well behaved client should not rely on"]
    #[doc = " wl_buffer.release events in this case. Alternatively, a client"]
    #[doc = " could create multiple wl_buffer objects from the same backing"]
    #[doc = " storage or use wp_linux_buffer_release."]
    #[doc = ""]
    #[doc = " Destroying the wl_buffer after wl_buffer.release does not change"]
    #[doc = " the surface contents. However, if the client destroys the"]
    #[doc = " wl_buffer before receiving the wl_buffer.release event, the"]
    #[doc = " surface contents become undefined immediately."]
    #[doc = ""]
    #[doc = " If wl_surface.attach is sent with a NULL wl_buffer, the"]
    #[doc = " following wl_surface.commit will remove the surface content."]
    #[doc = " @param buffer buffer of surface contents"]
    #[doc = " @param x surface-local x coordinate"]
    #[doc = " @param y surface-local y coordinate"]
    pub attach: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            buffer: *mut wl_resource,
            x: i32,
            y: i32,
        ),
    >,
    #[doc = " mark part of the surface damaged"]
    #[doc = ""]
    #[doc = " This request is used to describe the regions where the pending"]
    #[doc = " buffer is different from the current surface contents, and where"]
    #[doc = " the surface therefore needs to be repainted. The compositor"]
    #[doc = " ignores the parts of the damage that fall outside of the"]
    #[doc = " surface."]
    #[doc = ""]
    #[doc = " Damage is double-buffered state, see wl_surface.commit."]
    #[doc = ""]
    #[doc = " The damage rectangle is specified in surface-local coordinates,"]
    #[doc = " where x and y specify the upper left corner of the damage"]
    #[doc = " rectangle."]
    #[doc = ""]
    #[doc = " The initial value for pending damage is empty: no damage."]
    #[doc = " wl_surface.damage adds pending damage: the new pending damage is"]
    #[doc = " the union of old pending damage and the given rectangle."]
    #[doc = ""]
    #[doc = " wl_surface.commit assigns pending damage as the current damage,"]
    #[doc = " and clears pending damage. The server will clear the current"]
    #[doc = " damage as it repaints the surface."]
    #[doc = ""]
    #[doc = " Note! New clients should not use this request. Instead damage"]
    #[doc = " can be posted with wl_surface.damage_buffer which uses buffer"]
    #[doc = " coordinates instead of surface coordinates."]
    #[doc = " @param x surface-local x coordinate"]
    #[doc = " @param y surface-local y coordinate"]
    #[doc = " @param width width of damage rectangle"]
    #[doc = " @param height height of damage rectangle"]
    pub damage: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " request a frame throttling hint"]
    #[doc = ""]
    #[doc = " Request a notification when it is a good time to start drawing"]
    #[doc = " a new frame, by creating a frame callback. This is useful for"]
    #[doc = " throttling redrawing operations, and driving animations."]
    #[doc = ""]
    #[doc = " When a client is animating on a wl_surface, it can use the"]
    #[doc = " 'frame' request to get notified when it is a good time to draw"]
    #[doc = " and commit the next frame of animation. If the client commits an"]
    #[doc = " update earlier than that, it is likely that some updates will"]
    #[doc = " not make it to the display, and the client is wasting resources"]
    #[doc = " by drawing too often."]
    #[doc = ""]
    #[doc = " The frame request will take effect on the next"]
    #[doc = " wl_surface.commit. The notification will only be posted for one"]
    #[doc = " frame unless requested again. For a wl_surface, the"]
    #[doc = " notifications are posted in the order the frame requests were"]
    #[doc = " committed."]
    #[doc = ""]
    #[doc = " The server must send the notifications so that a client will not"]
    #[doc = " send excessive updates, while still allowing the highest"]
    #[doc = " possible update rate for clients that wait for the reply before"]
    #[doc = " drawing again. The server should give some time for the client"]
    #[doc = " to draw and commit after sending the frame callback events to"]
    #[doc = " let it hit the next output refresh."]
    #[doc = ""]
    #[doc = " A server should avoid signaling the frame callbacks if the"]
    #[doc = " surface is not visible in any way, e.g. the surface is"]
    #[doc = " off-screen, or completely obscured by other opaque surfaces."]
    #[doc = ""]
    #[doc = " The object returned by this request will be destroyed by the"]
    #[doc = " compositor after the callback is fired and as such the client"]
    #[doc = " must not attempt to use it after that point."]
    #[doc = ""]
    #[doc = " The callback_data passed in the callback is the current time, in"]
    #[doc = " milliseconds, with an undefined base."]
    #[doc = " @param callback callback object for the frame request"]
    pub frame: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, callback: u32),
    >,
    #[doc = " set opaque region"]
    #[doc = ""]
    #[doc = " This request sets the region of the surface that contains"]
    #[doc = " opaque content."]
    #[doc = ""]
    #[doc = " The opaque region is an optimization hint for the compositor"]
    #[doc = " that lets it optimize the redrawing of content behind opaque"]
    #[doc = " regions. Setting an opaque region is not required for correct"]
    #[doc = " behaviour, but marking transparent content as opaque will result"]
    #[doc = " in repaint artifacts."]
    #[doc = ""]
    #[doc = " The opaque region is specified in surface-local coordinates."]
    #[doc = ""]
    #[doc = " The compositor ignores the parts of the opaque region that fall"]
    #[doc = " outside of the surface."]
    #[doc = ""]
    #[doc = " Opaque region is double-buffered state, see wl_surface.commit."]
    #[doc = ""]
    #[doc = " wl_surface.set_opaque_region changes the pending opaque region."]
    #[doc = " wl_surface.commit copies the pending region to the current"]
    #[doc = " region. Otherwise, the pending and current regions are never"]
    #[doc = " changed."]
    #[doc = ""]
    #[doc = " The initial value for an opaque region is empty. Setting the"]
    #[doc = " pending opaque region has copy semantics, and the wl_region"]
    #[doc = " object can be destroyed immediately. A NULL wl_region causes the"]
    #[doc = " pending opaque region to be set to empty."]
    #[doc = " @param region opaque region of the surface"]
    pub set_opaque_region: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            region: *mut wl_resource,
        ),
    >,
    #[doc = " set input region"]
    #[doc = ""]
    #[doc = " This request sets the region of the surface that can receive"]
    #[doc = " pointer and touch events."]
    #[doc = ""]
    #[doc = " Input events happening outside of this region will try the next"]
    #[doc = " surface in the server surface stack. The compositor ignores the"]
    #[doc = " parts of the input region that fall outside of the surface."]
    #[doc = ""]
    #[doc = " The input region is specified in surface-local coordinates."]
    #[doc = ""]
    #[doc = " Input region is double-buffered state, see wl_surface.commit."]
    #[doc = ""]
    #[doc = " wl_surface.set_input_region changes the pending input region."]
    #[doc = " wl_surface.commit copies the pending region to the current"]
    #[doc = " region. Otherwise the pending and current regions are never"]
    #[doc = " changed, except cursor and icon surfaces are special cases, see"]
    #[doc = " wl_pointer.set_cursor and wl_data_device.start_drag."]
    #[doc = ""]
    #[doc = " The initial value for an input region is infinite. That means"]
    #[doc = " the whole surface will accept input. Setting the pending input"]
    #[doc = " region has copy semantics, and the wl_region object can be"]
    #[doc = " destroyed immediately. A NULL wl_region causes the input region"]
    #[doc = " to be set to infinite."]
    #[doc = " @param region input region of the surface"]
    pub set_input_region: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            region: *mut wl_resource,
        ),
    >,
    #[doc = " commit pending surface state"]
    #[doc = ""]
    #[doc = " Surface state (input, opaque, and damage regions, attached"]
    #[doc = " buffers, etc.) is double-buffered. Protocol requests modify the"]
    #[doc = " pending state, as opposed to the current state in use by the"]
    #[doc = " compositor. A commit request atomically applies all pending"]
    #[doc = " state, replacing the current state. After commit, the new"]
    #[doc = " pending state is as documented for each related request."]
    #[doc = ""]
    #[doc = " On commit, a pending wl_buffer is applied first, and all other"]
    #[doc = " state second. This means that all coordinates in double-buffered"]
    #[doc = " state are relative to the new wl_buffer coming into use, except"]
    #[doc = " for wl_surface.attach itself. If there is no pending wl_buffer,"]
    #[doc = " the coordinates are relative to the current surface contents."]
    #[doc = ""]
    #[doc = " All requests that need a commit to become effective are"]
    #[doc = " documented to affect double-buffered state."]
    #[doc = ""]
    #[doc = " Other interfaces may add further double-buffered surface state."]
    pub commit: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " sets the buffer transformation"]
    #[doc = ""]
    #[doc = " This request sets an optional transformation on how the"]
    #[doc = " compositor interprets the contents of the buffer attached to the"]
    #[doc = " surface. The accepted values for the transform parameter are the"]
    #[doc = " values for wl_output.transform."]
    #[doc = ""]
    #[doc = " Buffer transform is double-buffered state, see"]
    #[doc = " wl_surface.commit."]
    #[doc = ""]
    #[doc = " A newly created surface has its buffer transformation set to"]
    #[doc = " normal."]
    #[doc = ""]
    #[doc = " wl_surface.set_buffer_transform changes the pending buffer"]
    #[doc = " transformation. wl_surface.commit copies the pending buffer"]
    #[doc = " transformation to the current one. Otherwise, the pending and"]
    #[doc = " current values are never changed."]
    #[doc = ""]
    #[doc = " The purpose of this request is to allow clients to render"]
    #[doc = " content according to the output transform, thus permitting the"]
    #[doc = " compositor to use certain optimizations even if the display is"]
    #[doc = " rotated. Using hardware overlays and scanning out a client"]
    #[doc = " buffer for fullscreen surfaces are examples of such"]
    #[doc = " optimizations. Those optimizations are highly dependent on the"]
    #[doc = " compositor implementation, so the use of this request should be"]
    #[doc = " considered on a case-by-case basis."]
    #[doc = ""]
    #[doc = " Note that if the transform value includes 90 or 270 degree"]
    #[doc = " rotation, the width of the buffer will become the surface height"]
    #[doc = " and the height of the buffer will become the surface width."]
    #[doc = ""]
    #[doc = " If transform is not one of the values from the"]
    #[doc = " wl_output.transform enum the invalid_transform protocol error is"]
    #[doc = " raised."]
    #[doc = " @param transform transform for interpreting buffer contents"]
    #[doc = " @since 2"]
    pub set_buffer_transform: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, transform: i32),
    >,
    #[doc = " sets the buffer scaling factor"]
    #[doc = ""]
    #[doc = " This request sets an optional scaling factor on how the"]
    #[doc = " compositor interprets the contents of the buffer attached to the"]
    #[doc = " window."]
    #[doc = ""]
    #[doc = " Buffer scale is double-buffered state, see wl_surface.commit."]
    #[doc = ""]
    #[doc = " A newly created surface has its buffer scale set to 1."]
    #[doc = ""]
    #[doc = " wl_surface.set_buffer_scale changes the pending buffer scale."]
    #[doc = " wl_surface.commit copies the pending buffer scale to the current"]
    #[doc = " one. Otherwise, the pending and current values are never"]
    #[doc = " changed."]
    #[doc = ""]
    #[doc = " The purpose of this request is to allow clients to supply higher"]
    #[doc = " resolution buffer data for use on high resolution outputs. It is"]
    #[doc = " intended that you pick the same buffer scale as the scale of the"]
    #[doc = " output that the surface is displayed on. This means the"]
    #[doc = " compositor can avoid scaling when rendering the surface on that"]
    #[doc = " output."]
    #[doc = ""]
    #[doc = " Note that if the scale is larger than 1, then you have to attach"]
    #[doc = " a buffer that is larger (by a factor of scale in each dimension)"]
    #[doc = " than the desired surface size."]
    #[doc = ""]
    #[doc = " If scale is not positive the invalid_scale protocol error is"]
    #[doc = " raised."]
    #[doc = " @param scale positive scale for interpreting buffer contents"]
    #[doc = " @since 3"]
    pub set_buffer_scale: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, scale: i32),
    >,
    #[doc = " mark part of the surface damaged using buffer coordinates"]
    #[doc = ""]
    #[doc = " This request is used to describe the regions where the pending"]
    #[doc = " buffer is different from the current surface contents, and where"]
    #[doc = " the surface therefore needs to be repainted. The compositor"]
    #[doc = " ignores the parts of the damage that fall outside of the"]
    #[doc = " surface."]
    #[doc = ""]
    #[doc = " Damage is double-buffered state, see wl_surface.commit."]
    #[doc = ""]
    #[doc = " The damage rectangle is specified in buffer coordinates, where x"]
    #[doc = " and y specify the upper left corner of the damage rectangle."]
    #[doc = ""]
    #[doc = " The initial value for pending damage is empty: no damage."]
    #[doc = " wl_surface.damage_buffer adds pending damage: the new pending"]
    #[doc = " damage is the union of old pending damage and the given"]
    #[doc = " rectangle."]
    #[doc = ""]
    #[doc = " wl_surface.commit assigns pending damage as the current damage,"]
    #[doc = " and clears pending damage. The server will clear the current"]
    #[doc = " damage as it repaints the surface."]
    #[doc = ""]
    #[doc = " This request differs from wl_surface.damage in only one way - it"]
    #[doc = " takes damage in buffer coordinates instead of surface-local"]
    #[doc = " coordinates. While this generally is more intuitive than surface"]
    #[doc = " coordinates, it is especially desirable when using wp_viewport"]
    #[doc = " or when a drawing library (like EGL) is unaware of buffer scale"]
    #[doc = " and buffer transform."]
    #[doc = ""]
    #[doc = " Note: Because buffer transformation changes and damage requests"]
    #[doc = " may be interleaved in the protocol stream, it is impossible to"]
    #[doc = " determine the actual mapping between surface and buffer damage"]
    #[doc = " until wl_surface.commit time. Therefore, compositors wishing to"]
    #[doc = " take both kinds of damage into account will have to accumulate"]
    #[doc = " damage from the two requests separately and only transform from"]
    #[doc = " one to the other after receiving the wl_surface.commit."]
    #[doc = " @param x buffer-local x coordinate"]
    #[doc = " @param y buffer-local y coordinate"]
    #[doc = " @param width width of damage rectangle"]
    #[doc = " @param height height of damage rectangle"]
    #[doc = " @since 4"]
    pub damage_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_surface_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_surface_interface>(),
        80usize,
        concat!("Size of: ", stringify!(wl_surface_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_surface_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_surface_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).attach as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).damage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(damage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).frame as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).set_opaque_region as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(set_opaque_region)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).set_input_region as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(set_input_region)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_surface_interface>())).commit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).set_buffer_transform as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(set_buffer_transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).set_buffer_scale as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(set_buffer_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_surface_interface>())).damage_buffer as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_surface_interface),
            "::",
            stringify!(damage_buffer)
        )
    );
}
#[doc = " the seat has pointer devices"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_POINTER: wl_seat_capability = 1;
#[doc = " the seat has one or more keyboards"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_KEYBOARD: wl_seat_capability = 2;
#[doc = " the seat has touch devices"]
pub const wl_seat_capability_WL_SEAT_CAPABILITY_TOUCH: wl_seat_capability = 4;
#[doc = " @ingroup iface_wl_seat"]
#[doc = " seat capability bitmask"]
#[doc = ""]
#[doc = " This is a bitmask of capabilities this seat has; if a member is"]
#[doc = " set, then it is present on the seat."]
pub type wl_seat_capability = u32;
#[doc = " @ingroup iface_wl_seat"]
#[doc = " @struct wl_seat_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_seat_interface {
    #[doc = " return pointer object"]
    #[doc = ""]
    #[doc = " The ID provided will be initialized to the wl_pointer"]
    #[doc = " interface for this seat."]
    #[doc = ""]
    #[doc = " This request only takes effect if the seat has the pointer"]
    #[doc = " capability, or has had the pointer capability in the past. It is"]
    #[doc = " a protocol violation to issue this request on a seat that has"]
    #[doc = " never had the pointer capability."]
    #[doc = " @param id seat pointer"]
    pub get_pointer: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " return keyboard object"]
    #[doc = ""]
    #[doc = " The ID provided will be initialized to the wl_keyboard"]
    #[doc = " interface for this seat."]
    #[doc = ""]
    #[doc = " This request only takes effect if the seat has the keyboard"]
    #[doc = " capability, or has had the keyboard capability in the past. It"]
    #[doc = " is a protocol violation to issue this request on a seat that has"]
    #[doc = " never had the keyboard capability."]
    #[doc = " @param id seat keyboard"]
    pub get_keyboard: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " return touch object"]
    #[doc = ""]
    #[doc = " The ID provided will be initialized to the wl_touch interface"]
    #[doc = " for this seat."]
    #[doc = ""]
    #[doc = " This request only takes effect if the seat has the touch"]
    #[doc = " capability, or has had the touch capability in the past. It is a"]
    #[doc = " protocol violation to issue this request on a seat that has"]
    #[doc = " never had the touch capability."]
    #[doc = " @param id seat touch interface"]
    pub get_touch: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, id: u32),
    >,
    #[doc = " release the seat object"]
    #[doc = ""]
    #[doc = " Using this request a client can tell the server that it is not"]
    #[doc = " going to use the seat object anymore."]
    #[doc = " @since 5"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_seat_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_seat_interface>(),
        32usize,
        concat!("Size of: ", stringify!(wl_seat_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_seat_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_seat_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_seat_interface>())).get_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_seat_interface),
            "::",
            stringify!(get_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_seat_interface>())).get_keyboard as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_seat_interface),
            "::",
            stringify!(get_keyboard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_seat_interface>())).get_touch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_seat_interface),
            "::",
            stringify!(get_touch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_seat_interface>())).release as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_seat_interface),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " given wl_surface has another role"]
pub const wl_pointer_error_WL_POINTER_ERROR_ROLE: wl_pointer_error = 0;
pub type wl_pointer_error = u32;
#[doc = " the button is not pressed"]
pub const wl_pointer_button_state_WL_POINTER_BUTTON_STATE_RELEASED: wl_pointer_button_state = 0;
#[doc = " the button is pressed"]
pub const wl_pointer_button_state_WL_POINTER_BUTTON_STATE_PRESSED: wl_pointer_button_state = 1;
#[doc = " @ingroup iface_wl_pointer"]
#[doc = " physical button state"]
#[doc = ""]
#[doc = " Describes the physical state of a button that produced the button"]
#[doc = " event."]
pub type wl_pointer_button_state = u32;
#[doc = " vertical axis"]
pub const wl_pointer_axis_WL_POINTER_AXIS_VERTICAL_SCROLL: wl_pointer_axis = 0;
#[doc = " horizontal axis"]
pub const wl_pointer_axis_WL_POINTER_AXIS_HORIZONTAL_SCROLL: wl_pointer_axis = 1;
#[doc = " @ingroup iface_wl_pointer"]
#[doc = " axis types"]
#[doc = ""]
#[doc = " Describes the axis types of scroll events."]
pub type wl_pointer_axis = u32;
#[doc = " a physical wheel rotation"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_WHEEL: wl_pointer_axis_source = 0;
#[doc = " finger on a touch surface"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_FINGER: wl_pointer_axis_source = 1;
#[doc = " continuous coordinate space"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_CONTINUOUS: wl_pointer_axis_source = 2;
#[doc = " a physical wheel tilt"]
#[doc = " @since 6"]
pub const wl_pointer_axis_source_WL_POINTER_AXIS_SOURCE_WHEEL_TILT: wl_pointer_axis_source = 3;
#[doc = " @ingroup iface_wl_pointer"]
#[doc = " axis source types"]
#[doc = ""]
#[doc = " Describes the source types for axis events. This indicates to the"]
#[doc = " client how an axis event was physically generated; a client may"]
#[doc = " adjust the user interface accordingly. For example, scroll events"]
#[doc = " from a \"finger\" source may be in a smooth coordinate space with"]
#[doc = " kinetic scrolling whereas a \"wheel\" source may be in discrete steps"]
#[doc = " of a number of lines."]
#[doc = ""]
#[doc = " The \"continuous\" axis source is a device generating events in a"]
#[doc = " continuous coordinate space, but using something other than a"]
#[doc = " finger. One example for this source is button-based scrolling where"]
#[doc = " the vertical motion of a device is converted to scroll events while"]
#[doc = " a button is held down."]
#[doc = ""]
#[doc = " The \"wheel tilt\" axis source indicates that the actual device is a"]
#[doc = " wheel but the scroll event is not caused by a rotation but a"]
#[doc = " (usually sideways) tilt of the wheel."]
pub type wl_pointer_axis_source = u32;
#[doc = " @ingroup iface_wl_pointer"]
#[doc = " @struct wl_pointer_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_pointer_interface {
    #[doc = " set the pointer surface"]
    #[doc = ""]
    #[doc = " Set the pointer surface, i.e., the surface that contains the"]
    #[doc = " pointer image (cursor). This request gives the surface the role"]
    #[doc = " of a cursor. If the surface already has another role, it raises"]
    #[doc = " a protocol error."]
    #[doc = ""]
    #[doc = " The cursor actually changes only if the pointer focus for this"]
    #[doc = " device is one of the requesting client's surfaces or the surface"]
    #[doc = " parameter is the current pointer surface. If there was a"]
    #[doc = " previous surface set with this request it is replaced. If"]
    #[doc = " surface is NULL, the pointer image is hidden."]
    #[doc = ""]
    #[doc = " The parameters hotspot_x and hotspot_y define the position of"]
    #[doc = " the pointer surface relative to the pointer location. Its"]
    #[doc = " top-left corner is always at (x, y) - (hotspot_x, hotspot_y),"]
    #[doc = " where (x, y) are the coordinates of the pointer location, in"]
    #[doc = " surface-local coordinates."]
    #[doc = ""]
    #[doc = " On surface.attach requests to the pointer surface, hotspot_x and"]
    #[doc = " hotspot_y are decremented by the x and y parameters passed to"]
    #[doc = " the request. Attach must be confirmed by wl_surface.commit as"]
    #[doc = " usual."]
    #[doc = ""]
    #[doc = " The hotspot can also be updated by passing the currently set"]
    #[doc = " pointer surface to this request with new values for hotspot_x"]
    #[doc = " and hotspot_y."]
    #[doc = ""]
    #[doc = " The current and pending input regions of the wl_surface are"]
    #[doc = " cleared, and wl_surface.set_input_region is ignored until the"]
    #[doc = " wl_surface is no longer used as the cursor. When the use as a"]
    #[doc = " cursor ends, the current and pending input regions become"]
    #[doc = " undefined, and the wl_surface is unmapped."]
    #[doc = " @param serial serial number of the enter event"]
    #[doc = " @param surface pointer surface"]
    #[doc = " @param hotspot_x surface-local x coordinate"]
    #[doc = " @param hotspot_y surface-local y coordinate"]
    pub set_cursor: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            serial: u32,
            surface: *mut wl_resource,
            hotspot_x: i32,
            hotspot_y: i32,
        ),
    >,
    #[doc = " release the pointer object"]
    #[doc = ""]
    #[doc = " Using this request a client can tell the server that it is not"]
    #[doc = " going to use the pointer object anymore."]
    #[doc = ""]
    #[doc = " This request destroys the pointer proxy object, so clients must"]
    #[doc = " not call wl_pointer_destroy() after using this request."]
    #[doc = " @since 3"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_pointer_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_pointer_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_pointer_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_pointer_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_pointer_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_pointer_interface>())).set_cursor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_pointer_interface),
            "::",
            stringify!(set_cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_pointer_interface>())).release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_pointer_interface),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " no keymap; client must understand how to interpret the raw keycode"]
pub const wl_keyboard_keymap_format_WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP: wl_keyboard_keymap_format =
    0;
#[doc = " libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode"]
pub const wl_keyboard_keymap_format_WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1: wl_keyboard_keymap_format = 1;
#[doc = " @ingroup iface_wl_keyboard"]
#[doc = " keyboard mapping format"]
#[doc = ""]
#[doc = " This specifies the format of the keymap provided to the"]
#[doc = " client with the wl_keyboard.keymap event."]
pub type wl_keyboard_keymap_format = u32;
#[doc = " key is not pressed"]
pub const wl_keyboard_key_state_WL_KEYBOARD_KEY_STATE_RELEASED: wl_keyboard_key_state = 0;
#[doc = " key is pressed"]
pub const wl_keyboard_key_state_WL_KEYBOARD_KEY_STATE_PRESSED: wl_keyboard_key_state = 1;
#[doc = " @ingroup iface_wl_keyboard"]
#[doc = " physical key state"]
#[doc = ""]
#[doc = " Describes the physical state of a key that produced the key event."]
pub type wl_keyboard_key_state = u32;
#[doc = " @ingroup iface_wl_keyboard"]
#[doc = " @struct wl_keyboard_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_keyboard_interface {
    #[doc = " release the keyboard object"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @since 3"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_keyboard_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_keyboard_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_keyboard_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_keyboard_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_keyboard_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_keyboard_interface>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_keyboard_interface),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " @ingroup iface_wl_touch"]
#[doc = " @struct wl_touch_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_touch_interface {
    #[doc = " release the touch object"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @since 3"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_touch_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_touch_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_touch_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_touch_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_touch_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_touch_interface>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_touch_interface),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " unknown geometry"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_UNKNOWN: wl_output_subpixel = 0;
#[doc = " no geometry"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_NONE: wl_output_subpixel = 1;
#[doc = " horizontal RGB"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: wl_output_subpixel = 2;
#[doc = " horizontal BGR"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: wl_output_subpixel = 3;
#[doc = " vertical RGB"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: wl_output_subpixel = 4;
#[doc = " vertical BGR"]
pub const wl_output_subpixel_WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: wl_output_subpixel = 5;
#[doc = " @ingroup iface_wl_output"]
#[doc = " subpixel geometry information"]
#[doc = ""]
#[doc = " This enumeration describes how the physical"]
#[doc = " pixels on an output are laid out."]
pub type wl_output_subpixel = u32;
#[doc = " no transform"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_NORMAL: wl_output_transform = 0;
#[doc = " 90 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_90: wl_output_transform = 1;
#[doc = " 180 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_180: wl_output_transform = 2;
#[doc = " 270 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_270: wl_output_transform = 3;
#[doc = " 180 degree flip around a vertical axis"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED: wl_output_transform = 4;
#[doc = " flip and rotate 90 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_90: wl_output_transform = 5;
#[doc = " flip and rotate 180 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_180: wl_output_transform = 6;
#[doc = " flip and rotate 270 degrees counter-clockwise"]
pub const wl_output_transform_WL_OUTPUT_TRANSFORM_FLIPPED_270: wl_output_transform = 7;
#[doc = " @ingroup iface_wl_output"]
#[doc = " transform from framebuffer to output"]
#[doc = ""]
#[doc = " This describes the transform that a compositor will apply to a"]
#[doc = " surface to compensate for the rotation or mirroring of an"]
#[doc = " output device."]
#[doc = ""]
#[doc = " The flipped values correspond to an initial flip around a"]
#[doc = " vertical axis followed by rotation."]
#[doc = ""]
#[doc = " The purpose is mainly to allow clients to render accordingly and"]
#[doc = " tell the compositor, so that for fullscreen surfaces, the"]
#[doc = " compositor will still be able to scan out directly from client"]
#[doc = " surfaces."]
pub type wl_output_transform = u32;
#[doc = " indicates this is the current mode"]
pub const wl_output_mode_WL_OUTPUT_MODE_CURRENT: wl_output_mode = 1;
#[doc = " indicates this is the preferred mode"]
pub const wl_output_mode_WL_OUTPUT_MODE_PREFERRED: wl_output_mode = 2;
#[doc = " @ingroup iface_wl_output"]
#[doc = " mode information"]
#[doc = ""]
#[doc = " These flags describe properties of an output mode."]
#[doc = " They are used in the flags bitfield of the mode event."]
pub type wl_output_mode = u32;
#[doc = " @ingroup iface_wl_output"]
#[doc = " @struct wl_output_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output_interface {
    #[doc = " release the output object"]
    #[doc = ""]
    #[doc = " Using this request a client can tell the server that it is not"]
    #[doc = " going to use the output object anymore."]
    #[doc = " @since 3"]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_output_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_output_interface>(),
        8usize,
        concat!("Size of: ", stringify!(wl_output_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_output_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_output_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_output_interface>())).release as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_output_interface),
            "::",
            stringify!(release)
        )
    );
}
#[doc = " @ingroup iface_wl_region"]
#[doc = " @struct wl_region_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_region_interface {
    #[doc = " destroy region"]
    #[doc = ""]
    #[doc = " Destroy the region. This will invalidate the object ID."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " add rectangle to region"]
    #[doc = ""]
    #[doc = " Add the specified rectangle to the region."]
    #[doc = " @param x region-local x coordinate"]
    #[doc = " @param y region-local y coordinate"]
    #[doc = " @param width rectangle width"]
    #[doc = " @param height rectangle height"]
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
    #[doc = " subtract rectangle from region"]
    #[doc = ""]
    #[doc = " Subtract the specified rectangle from the region."]
    #[doc = " @param x region-local x coordinate"]
    #[doc = " @param y region-local y coordinate"]
    #[doc = " @param width rectangle width"]
    #[doc = " @param height rectangle height"]
    pub subtract: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            x: i32,
            y: i32,
            width: i32,
            height: i32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_region_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_region_interface>(),
        24usize,
        concat!("Size of: ", stringify!(wl_region_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_region_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_region_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_region_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_region_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_region_interface>())).add as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_region_interface),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_region_interface>())).subtract as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_region_interface),
            "::",
            stringify!(subtract)
        )
    );
}
#[doc = " the to-be sub-surface is invalid"]
pub const wl_subcompositor_error_WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE: wl_subcompositor_error = 0;
pub type wl_subcompositor_error = u32;
#[doc = " @ingroup iface_wl_subcompositor"]
#[doc = " @struct wl_subcompositor_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subcompositor_interface {
    #[doc = " unbind from the subcompositor interface"]
    #[doc = ""]
    #[doc = " Informs the server that the client will not be using this"]
    #[doc = " protocol object anymore. This does not affect any other objects,"]
    #[doc = " wl_subsurface objects included."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " give a surface the role sub-surface"]
    #[doc = ""]
    #[doc = " Create a sub-surface interface for the given surface, and"]
    #[doc = " associate it with the given parent surface. This turns a plain"]
    #[doc = " wl_surface into a sub-surface."]
    #[doc = ""]
    #[doc = " The to-be sub-surface must not already have another role, and it"]
    #[doc = " must not have an existing wl_subsurface object. Otherwise a"]
    #[doc = " protocol error is raised."]
    #[doc = ""]
    #[doc = " Adding sub-surfaces to a parent is a double-buffered operation"]
    #[doc = " on the parent (see wl_surface.commit). The effect of adding a"]
    #[doc = " sub-surface becomes visible on the next time the state of the"]
    #[doc = " parent surface is applied."]
    #[doc = ""]
    #[doc = " This request modifies the behaviour of wl_surface.commit request"]
    #[doc = " on the sub-surface, see the documentation on wl_subsurface"]
    #[doc = " interface."]
    #[doc = " @param id the new sub-surface object ID"]
    #[doc = " @param surface the surface to be turned into a sub-surface"]
    #[doc = " @param parent the parent surface"]
    pub get_subsurface: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            id: u32,
            surface: *mut wl_resource,
            parent: *mut wl_resource,
        ),
    >,
}
#[test]
fn bindgen_test_layout_wl_subcompositor_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_subcompositor_interface>(),
        16usize,
        concat!("Size of: ", stringify!(wl_subcompositor_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_subcompositor_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_subcompositor_interface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subcompositor_interface>())).destroy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subcompositor_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subcompositor_interface>())).get_subsurface as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subcompositor_interface),
            "::",
            stringify!(get_subsurface)
        )
    );
}
#[doc = " wl_surface is not a sibling or the parent"]
pub const wl_subsurface_error_WL_SUBSURFACE_ERROR_BAD_SURFACE: wl_subsurface_error = 0;
pub type wl_subsurface_error = u32;
#[doc = " @ingroup iface_wl_subsurface"]
#[doc = " @struct wl_subsurface_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_subsurface_interface {
    #[doc = " remove sub-surface interface"]
    #[doc = ""]
    #[doc = " The sub-surface interface is removed from the wl_surface"]
    #[doc = " object that was turned into a sub-surface with a"]
    #[doc = " wl_subcompositor.get_subsurface request. The wl_surface's"]
    #[doc = " association to the parent is deleted, and the wl_surface loses"]
    #[doc = " its role as a sub-surface. The wl_surface is unmapped"]
    #[doc = " immediately."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " reposition the sub-surface"]
    #[doc = ""]
    #[doc = " This schedules a sub-surface position change. The sub-surface"]
    #[doc = " will be moved so that its origin (top left corner pixel) will be"]
    #[doc = " at the location x, y of the parent surface coordinate system."]
    #[doc = " The coordinates are not restricted to the parent surface area."]
    #[doc = " Negative values are allowed."]
    #[doc = ""]
    #[doc = " The scheduled coordinates will take effect whenever the state of"]
    #[doc = " the parent surface is applied. When this happens depends on"]
    #[doc = " whether the parent surface is in synchronized mode or not. See"]
    #[doc = " wl_subsurface.set_sync and wl_subsurface.set_desync for details."]
    #[doc = ""]
    #[doc = " If more than one set_position request is invoked by the client"]
    #[doc = " before the commit of the parent surface, the position of a new"]
    #[doc = " request always replaces the scheduled position from any previous"]
    #[doc = " request."]
    #[doc = ""]
    #[doc = " The initial position is 0, 0."]
    #[doc = " @param x x coordinate in the parent surface"]
    #[doc = " @param y y coordinate in the parent surface"]
    pub set_position: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource, x: i32, y: i32),
    >,
    #[doc = " restack the sub-surface"]
    #[doc = ""]
    #[doc = " This sub-surface is taken from the stack, and put back just"]
    #[doc = " above the reference surface, changing the z-order of the"]
    #[doc = " sub-surfaces. The reference surface must be one of the sibling"]
    #[doc = " surfaces, or the parent surface. Using any other surface,"]
    #[doc = " including this sub-surface, will cause a protocol error."]
    #[doc = ""]
    #[doc = " The z-order is double-buffered. Requests are handled in order"]
    #[doc = " and applied immediately to a pending state. The final pending"]
    #[doc = " state is copied to the active state the next time the state of"]
    #[doc = " the parent surface is applied. When this happens depends on"]
    #[doc = " whether the parent surface is in synchronized mode or not. See"]
    #[doc = " wl_subsurface.set_sync and wl_subsurface.set_desync for details."]
    #[doc = ""]
    #[doc = " A new sub-surface is initially added as the top-most in the"]
    #[doc = " stack of its siblings and parent."]
    #[doc = " @param sibling the reference surface"]
    pub place_above: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            sibling: *mut wl_resource,
        ),
    >,
    #[doc = " restack the sub-surface"]
    #[doc = ""]
    #[doc = " The sub-surface is placed just below the reference surface."]
    #[doc = " See wl_subsurface.place_above."]
    #[doc = " @param sibling the reference surface"]
    pub place_below: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut wl_client,
            resource: *mut wl_resource,
            sibling: *mut wl_resource,
        ),
    >,
    #[doc = " set sub-surface to synchronized mode"]
    #[doc = ""]
    #[doc = " Change the commit behaviour of the sub-surface to synchronized"]
    #[doc = " mode, also described as the parent dependent mode."]
    #[doc = ""]
    #[doc = " In synchronized mode, wl_surface.commit on a sub-surface will"]
    #[doc = " accumulate the committed state in a cache, but the state will"]
    #[doc = " not be applied and hence will not change the compositor output."]
    #[doc = " The cached state is applied to the sub-surface immediately after"]
    #[doc = " the parent surface's state is applied. This ensures atomic"]
    #[doc = " updates of the parent and all its synchronized sub-surfaces."]
    #[doc = " Applying the cached state will invalidate the cache, so further"]
    #[doc = " parent surface commits do not (re-)apply old state."]
    #[doc = ""]
    #[doc = " See wl_subsurface for the recursive effect of this mode."]
    pub set_sync: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
    #[doc = " set sub-surface to desynchronized mode"]
    #[doc = ""]
    #[doc = " Change the commit behaviour of the sub-surface to"]
    #[doc = " desynchronized mode, also described as independent or freely"]
    #[doc = " running mode."]
    #[doc = ""]
    #[doc = " In desynchronized mode, wl_surface.commit on a sub-surface will"]
    #[doc = " apply the pending state directly, without caching, as happens"]
    #[doc = " normally with a wl_surface. Calling wl_surface.commit on the"]
    #[doc = " parent surface has no effect on the sub-surface's wl_surface"]
    #[doc = " state. This mode allows a sub-surface to be updated on its own."]
    #[doc = ""]
    #[doc = " If cached state exists when wl_surface.commit is called in"]
    #[doc = " desynchronized mode, the pending state is added to the cached"]
    #[doc = " state, and applied as a whole. This invalidates the cache."]
    #[doc = ""]
    #[doc = " Note: even if a sub-surface is set to desynchronized, a parent"]
    #[doc = " sub-surface may override it to behave as synchronized. For"]
    #[doc = " details, see wl_subsurface."]
    #[doc = ""]
    #[doc = " If a surface's parent surface behaves as desynchronized, then"]
    #[doc = " the cached state is applied on set_desync."]
    pub set_desync: ::std::option::Option<
        unsafe extern "C" fn(client: *mut wl_client, resource: *mut wl_resource),
    >,
}
#[test]
fn bindgen_test_layout_wl_subsurface_interface() {
    assert_eq!(
        ::std::mem::size_of::<wl_subsurface_interface>(),
        48usize,
        concat!("Size of: ", stringify!(wl_subsurface_interface))
    );
    assert_eq!(
        ::std::mem::align_of::<wl_subsurface_interface>(),
        8usize,
        concat!("Alignment of ", stringify!(wl_subsurface_interface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wl_subsurface_interface>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).set_position as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(set_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).place_above as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(place_above)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).place_below as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(place_below)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).set_sync as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(set_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<wl_subsurface_interface>())).set_desync as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(wl_subsurface_interface),
            "::",
            stringify!(set_desync)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
